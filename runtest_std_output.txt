Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, =)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
AssignmentExprAST (Line 1, Column 1): name = a
  NumberExprAST (Line 1, Column 5): val = 0.000000
Token (TOKEN_IDENTIFIER, b)
Token (TOKEN_LETTER, =)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
AssignmentExprAST (Line 2, Column 1): name = b
  NumberExprAST (Line 2, Column 5): val = 0.000000
Token (TOKEN_IDENTIFIER, c)
Token (TOKEN_LETTER, =)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
AssignmentExprAST (Line 3, Column 1): name = c
  NumberExprAST (Line 3, Column 5): val = 0.000000
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_OP, *)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 5, Column 3): op = +
  NumberExprAST (Line 5, Column 1): val = 3.000000
  BinaryExprAST (Line 5, Column 7): op = *
    NumberExprAST (Line 5, Column 5): val = 4.000000
    NumberExprAST (Line 5, Column 9): val = 2.000000
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, +)
unread Token (TOKEN_OP, +)
Token (TOKEN_OP, +)
unread Token (TOKEN_OP, +)
Token (TOKEN_OP, +)
Token (TOKEN_IDENTIFIER, b)
Token (TOKEN_OP, *)
unread Token (TOKEN_OP, *)
Token (TOKEN_OP, *)
Token (TOKEN_IDENTIFIER, c)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 6, Column 3): op = +
  VariableExprAST (Line 6, Column 1): name = a
  BinaryExprAST (Line 6, Column 7): op = *
    VariableExprAST (Line 6, Column 5): name = b
    VariableExprAST (Line 6, Column 9): name = c
Token (TOKEN_EXTERN)
Token (TOKEN_IDENTIFIER, extern_a)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, extern_b)
Token (TOKEN_LETTER, ,)
Token (TOKEN_IDENTIFIER, extern_c)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
PrototypeAST (Line 8, Column 8): extern_a (extern_b, extern_c)
Token (TOKEN_DEF)
Token (TOKEN_IDENTIFIER, def_a)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, def_b)
Token (TOKEN_LETTER, ,)
Token (TOKEN_IDENTIFIER, def_c)
Token (TOKEN_LETTER, ))
Token (TOKEN_IDENTIFIER, def_b)
Token (TOKEN_OP, +)
unread Token (TOKEN_OP, +)
Token (TOKEN_OP, +)
unread Token (TOKEN_OP, +)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_OP, *)
Token (TOKEN_IDENTIFIER, def_c)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
Token (TOKEN_NUMBER, 6.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
FunctionAST (Line 10, Column 1):
  PrototypeAST (Line 10, Column 5): def_a (def_b, def_c)
  BinaryExprAST (Line 11, Column 21): op = -
    BinaryExprAST (Line 11, Column 9): op = +
      VariableExprAST (Line 11, Column 3): name = def_b
      BinaryExprAST (Line 11, Column 13): op = *
        NumberExprAST (Line 11, Column 11): val = 2.000000
        VariableExprAST (Line 11, Column 15): name = def_c
    NumberExprAST (Line 11, Column 23): val = 6.000000
Token (TOKEN_IDENTIFIER, def_a)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ,)
unread Token (TOKEN_LETTER, ,)
Token (TOKEN_LETTER, ,)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
CallExprAST (Line 13, Column 1): Callee = def_a
  Arg #0:
    NumberExprAST (Line 13, Column 7): val = 2.000000
  Arg #1:
    NumberExprAST (Line 13, Column 10): val = 4.000000
Token (TOKEN_DEF)
Token (TOKEN_IDENTIFIER, cse_test)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, x)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_OP, +)
Token (TOKEN_IDENTIFIER, x)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_OP, *)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, x)
Token (TOKEN_OP, +)
unread Token (TOKEN_OP, +)
Token (TOKEN_OP, +)
unread Token (TOKEN_OP, +)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
FunctionAST (Line 17, Column 1):
  PrototypeAST (Line 17, Column 5): cse_test (x)
  BinaryExprAST (Line 17, Column 23): op = *
    BinaryExprAST (Line 17, Column 19): op = +
      NumberExprAST (Line 17, Column 18): val = 3.000000
      VariableExprAST (Line 17, Column 20): name = x
    BinaryExprAST (Line 17, Column 27): op = +
      VariableExprAST (Line 17, Column 26): name = x
      NumberExprAST (Line 17, Column 28): val = 3.000000
Token (TOKEN_DEF)
Token (TOKEN_IDENTIFIER, ta)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, b)
Token (TOKEN_LETTER, ,)
Token (TOKEN_IDENTIFIER, c)
Token (TOKEN_LETTER, ))
Token (TOKEN_IDENTIFIER, b)
Token (TOKEN_OP, *)
unread Token (TOKEN_OP, *)
Token (TOKEN_OP, *)
unread Token (TOKEN_OP, *)
Token (TOKEN_OP, *)
Token (TOKEN_IDENTIFIER, c)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
FunctionAST (Line 19, Column 1):
  PrototypeAST (Line 19, Column 5): ta (b, c)
  BinaryExprAST (Line 19, Column 14): op = *
    VariableExprAST (Line 19, Column 13): name = b
    VariableExprAST (Line 19, Column 15): name = c
Token (TOKEN_IDENTIFIER, ta)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_LETTER, ,)
unread Token (TOKEN_LETTER, ,)
Token (TOKEN_LETTER, ,)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
CallExprAST (Line 20, Column 1): Callee = ta
  Arg #0:
    NumberExprAST (Line 20, Column 4): val = 3.000000
  Arg #1:
    NumberExprAST (Line 20, Column 6): val = 4.000000
Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_ELSE)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
IfExprAST (Line 22, Column 1): have 1 CondThenExprs, have 1 ElseExpr
  CondExpr #1
    VariableExprAST (Line 22, Column 5): name = a
  ThenExpr #1
    NumberExprAST (Line 22, Column 8): val = 3.000000
  ElseExpr
    NumberExprAST (Line 22, Column 16): val = 4.000000
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
Token (TOKEN_NUMBER, 6.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
BlockExprAST (Line 24, Column 1): have 2 exprs
  BinaryExprAST (Line 25, Column 2): op = +
    NumberExprAST (Line 25, Column 1): val = 3.000000
    NumberExprAST (Line 25, Column 3): val = 2.000000
  BinaryExprAST (Line 26, Column 2): op = -
    VariableExprAST (Line 26, Column 1): name = a
    NumberExprAST (Line 26, Column 3): val = 6.000000
Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELSE)
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 7.000000)
Token (TOKEN_OP, -)
Token (TOKEN_NUMBER, 5.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
IfExprAST (Line 29, Column 1): have 1 CondThenExprs, have 1 ElseExpr
  CondExpr #1
    VariableExprAST (Line 29, Column 5): name = a
  ThenExpr #1
    BlockExprAST (Line 29, Column 8): have 1 exprs
      BinaryExprAST (Line 30, Column 4): op = +
        NumberExprAST (Line 30, Column 3): val = 3.000000
        NumberExprAST (Line 30, Column 5): val = 2.000000
  ElseExpr
    BlockExprAST (Line 31, Column 8): have 1 exprs
      BinaryExprAST (Line 32, Column 4): op = -
        NumberExprAST (Line 32, Column 3): val = 7.000000
        NumberExprAST (Line 32, Column 5): val = 5.000000
Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELSE)
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 7.000000)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
IfExprAST (Line 35, Column 1): have 1 CondThenExprs, have 1 ElseExpr
  CondExpr #1
    NumberExprAST (Line 35, Column 5): val = 1.000000
  ThenExpr #1
    BlockExprAST (Line 35, Column 8): have 1 exprs
      BinaryExprAST (Line 36, Column 4): op = +
        NumberExprAST (Line 36, Column 3): val = 4.000000
        NumberExprAST (Line 36, Column 5): val = 1.000000
  ElseExpr
    BlockExprAST (Line 37, Column 8): have 1 exprs
      BinaryExprAST (Line 38, Column 4): op = +
        NumberExprAST (Line 38, Column 3): val = 7.000000
        NumberExprAST (Line 38, Column 5): val = 4.000000
Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELIF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_IF)
unread Token (TOKEN_IF)
IfExprAST (Line 41, Column 1): have 2 CondThenExprs, have 0 ElseExpr
  CondExpr #1
    NumberExprAST (Line 41, Column 5): val = 0.000000
  ThenExpr #1
    BlockExprAST (Line 41, Column 8): have 1 exprs
      NumberExprAST (Line 42, Column 3): val = 0.000000
  CondExpr #2
    NumberExprAST (Line 43, Column 9): val = 1.000000
  ThenExpr #2
    BlockExprAST (Line 43, Column 12): have 1 exprs
      NumberExprAST (Line 44, Column 3): val = 1.000000
Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELIF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELIF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELSE)
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
IfExprAST (Line 47, Column 1): have 3 CondThenExprs, have 1 ElseExpr
  CondExpr #1
    NumberExprAST (Line 47, Column 5): val = 0.000000
  ThenExpr #1
    BlockExprAST (Line 47, Column 8): have 1 exprs
      NumberExprAST (Line 48, Column 3): val = 0.000000
  CondExpr #2
    NumberExprAST (Line 49, Column 9): val = 1.000000
  ThenExpr #2
    BlockExprAST (Line 49, Column 12): have 1 exprs
      NumberExprAST (Line 50, Column 3): val = 1.000000
  CondExpr #3
    NumberExprAST (Line 51, Column 9): val = 2.000000
  ThenExpr #3
    BlockExprAST (Line 51, Column 12): have 1 exprs
      NumberExprAST (Line 52, Column 3): val = 2.000000
  ElseExpr
    BlockExprAST (Line 53, Column 8): have 1 exprs
      NumberExprAST (Line 54, Column 3): val = 3.000000
Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELSE)
Token (TOKEN_LETTER, {)
Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELSE)
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_LETTER, })
IfExprAST (Line 57, Column 1): have 1 CondThenExprs, have 1 ElseExpr
  CondExpr #1
    NumberExprAST (Line 57, Column 5): val = 0.000000
  ThenExpr #1
    BlockExprAST (Line 57, Column 8): have 1 exprs
      NumberExprAST (Line 58, Column 3): val = 0.000000
  ElseExpr
    BlockExprAST (Line 59, Column 8): have 1 exprs
      IfExprAST (Line 60, Column 3): have 1 CondThenExprs, have 1 ElseExpr
        CondExpr #1
          VariableExprAST (Line 60, Column 7): name = a
        ThenExpr #1
          BlockExprAST (Line 60, Column 10): have 1 exprs
            NumberExprAST (Line 61, Column 5): val = 1.000000
        ElseExpr
          BlockExprAST (Line 62, Column 10): have 1 exprs
            NumberExprAST (Line 63, Column 5): val = 2.000000
Token (TOKEN_EXTERN)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, x)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
PrototypeAST (Line 67, Column 8): printc (x)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
CallExprAST (Line 68, Column 1): Callee = printc
  Arg #0:
    NumberExprAST (Line 68, Column 8): val = 42.000000
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 10.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
CallExprAST (Line 69, Column 1): Callee = printc
  Arg #0:
    NumberExprAST (Line 69, Column 8): val = 10.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, <)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 70, Column 3): op = <
  NumberExprAST (Line 70, Column 1): val = 1.000000
  NumberExprAST (Line 70, Column 5): val = 2.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, <)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 71, Column 3): op = <
  NumberExprAST (Line 71, Column 1): val = 1.000000
  NumberExprAST (Line 71, Column 5): val = 0.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, <=)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 72, Column 3): op = <=
  NumberExprAST (Line 72, Column 1): val = 1.000000
  NumberExprAST (Line 72, Column 6): val = 1.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, <=)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 73, Column 3): op = <=
  NumberExprAST (Line 73, Column 1): val = 1.000000
  NumberExprAST (Line 73, Column 6): val = 0.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, ==)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 74, Column 3): op = ==
  NumberExprAST (Line 74, Column 1): val = 1.000000
  NumberExprAST (Line 74, Column 6): val = 1.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, !=)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 75, Column 3): op = !=
  NumberExprAST (Line 75, Column 1): val = 1.000000
  NumberExprAST (Line 75, Column 6): val = 2.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, >)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 76, Column 3): op = >
  NumberExprAST (Line 76, Column 1): val = 1.000000
  NumberExprAST (Line 76, Column 5): val = 0.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, >=)
Token (TOKEN_NUMBER, 5.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 77, Column 3): op = >=
  NumberExprAST (Line 77, Column 1): val = 1.000000
  NumberExprAST (Line 77, Column 6): val = 5.000000
Token (TOKEN_FOR)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, =)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, <=)
unread Token (TOKEN_OP, <=)
Token (TOKEN_OP, <=)
unread Token (TOKEN_OP, <=)
Token (TOKEN_OP, <=)
Token (TOKEN_NUMBER, 20.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, =)
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, +)
unread Token (TOKEN_OP, +)
Token (TOKEN_OP, +)
unread Token (TOKEN_OP, +)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
ForExprAST (Line 79, Column 1):
  InitExpr:
    AssignmentExprAST (Line 79, Column 6): name = a
      NumberExprAST (Line 79, Column 10): val = 1.000000
  CondExpr:
    BinaryExprAST (Line 79, Column 15): op = <=
      VariableExprAST (Line 79, Column 13): name = a
      NumberExprAST (Line 79, Column 18): val = 20.000000
  NextExpr:
    AssignmentExprAST (Line 79, Column 22): name = a
      BinaryExprAST (Line 79, Column 28): op = +
        VariableExprAST (Line 79, Column 26): name = a
        NumberExprAST (Line 79, Column 30): val = 1.000000
  BlockExpr:
    BlockExprAST (Line 79, Column 33): have 1 exprs
      CallExprAST (Line 80, Column 3): Callee = printc
        Arg #0:
          NumberExprAST (Line 80, Column 10): val = 42.000000
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 10.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
CallExprAST (Line 82, Column 1): Callee = printc
  Arg #0:
    NumberExprAST (Line 82, Column 8): val = 10.000000
Token (TOKEN_DEF)
Token (TOKEN_BINARY)
Token (TOKEN_LETTER, :)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, LHS)
Token (TOKEN_LETTER, ,)
Token (TOKEN_IDENTIFIER, RHS)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_IDENTIFIER, LHS)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_IDENTIFIER, RHS)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
FunctionAST (Line 84, Column 1):
  PrototypeAST (Line 84, Column 5): binary: (LHS, RHS)
  BlockExprAST (Line 84, Column 24): have 2 exprs
    VariableExprAST (Line 85, Column 2): name = LHS
    VariableExprAST (Line 86, Column 2): name = RHS
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_OP, :)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 10.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 89, Column 12): op = :
  CallExprAST (Line 89, Column 1): Callee = printc
    Arg #0:
      NumberExprAST (Line 89, Column 8): val = 42.000000
  CallExprAST (Line 89, Column 14): Callee = printc
    Arg #0:
      NumberExprAST (Line 89, Column 21): val = 10.000000
Token (TOKEN_DEF)
Token (TOKEN_UNARY)
Token (TOKEN_LETTER, !)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, RHS)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, RHS)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_ELSE)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
FunctionAST (Line 91, Column 1):
  PrototypeAST (Line 91, Column 5): unary! (RHS)
  BlockExprAST (Line 91, Column 18): have 1 exprs
    IfExprAST (Line 92, Column 3): have 1 CondThenExprs, have 1 ElseExpr
      CondExpr #1
        VariableExprAST (Line 92, Column 7): name = RHS
      ThenExpr #1
        NumberExprAST (Line 92, Column 12): val = 0.000000
      ElseExpr
        NumberExprAST (Line 92, Column 20): val = 1.000000
Token (TOKEN_OP, !)
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
UnaryExprAST (Line 95, Column 1): op = !
  NumberExprAST (Line 95, Column 2): val = 3.000000
Token (TOKEN_OP, !)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
UnaryExprAST (Line 96, Column 1): op = !
  NumberExprAST (Line 96, Column 2): val = 0.000000
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, =)
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
AssignmentExprAST (Line 98, Column 1): name = a
  NumberExprAST (Line 98, Column 5): val = 42.000000
Token (TOKEN_DEF)
Token (TOKEN_IDENTIFIER, a_function)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, =)
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_OP, :)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
Token (TOKEN_NUMBER, 32.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
FunctionAST (Line 99, Column 1):
  PrototypeAST (Line 99, Column 5): a_function (a)
  BlockExprAST (Line 99, Column 19): have 2 exprs
    AssignmentExprAST (Line 100, Column 3): name = a
      NumberExprAST (Line 100, Column 7): val = 42.000000
    BinaryExprAST (Line 101, Column 13): op = :
      CallExprAST (Line 101, Column 3): Callee = printc
        Arg #0:
          VariableExprAST (Line 101, Column 10): name = a
      CallExprAST (Line 101, Column 15): Callee = printc
        Arg #0:
          BinaryExprAST (Line 101, Column 24): op = -
            VariableExprAST (Line 101, Column 22): name = a
            NumberExprAST (Line 101, Column 26): val = 32.000000
Token (TOKEN_IDENTIFIER, a_function)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
CallExprAST (Line 104, Column 1): Callee = a_function
  Arg #0:
    NumberExprAST (Line 104, Column 12): val = 42.000000
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_OP, :)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_OP, :)
unread Token (TOKEN_OP, :)
Token (TOKEN_OP, :)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
Token (TOKEN_NUMBER, 32.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 105, Column 23): op = :
  BinaryExprAST (Line 105, Column 11): op = :
    CallExprAST (Line 105, Column 1): Callee = printc
      Arg #0:
        VariableExprAST (Line 105, Column 8): name = a
    CallExprAST (Line 105, Column 13): Callee = printc
      Arg #0:
        VariableExprAST (Line 105, Column 20): name = a
  CallExprAST (Line 105, Column 25): Callee = printc
    Arg #0:
      BinaryExprAST (Line 105, Column 34): op = -
        VariableExprAST (Line 105, Column 32): name = a
        NumberExprAST (Line 105, Column 36): val = 32.000000
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, *)
unread Token (TOKEN_OP, *)
Token (TOKEN_OP, *)
unread Token (TOKEN_OP, *)
Token (TOKEN_OP, *)
Token (TOKEN_NUMBER, 5.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 106, Column 3): op = *
  VariableExprAST (Line 106, Column 1): name = a
  NumberExprAST (Line 106, Column 5): val = 5.000000
Token (TOKEN_EOF)
; ModuleID = 'tmpmodule.1'

@a = internal global double 0.000000e+00
@b = internal global double 0.000000e+00
@c = internal global double 0.000000e+00

define internal double @__toy_main() {
  store double 0.000000e+00, double* @a
  store double 0.000000e+00, double* @b
  store double 0.000000e+00, double* @c
  %tmp.3 = load double, double* @a
  %tmp.4 = load double, double* @b
  %tmp.5 = load double, double* @c
  %tmp.6 = fmul double %tmp.4, %tmp.5
  %tmp.7 = fadd double %tmp.3, %tmp.6
  %tmp.13 = call double @def_a(double 2.000000e+00, double 4.000000e+00)
  %tmp.22 = call double @ta(double 3.000000e+00, double 4.000000e+00)
  %tmp.23 = load double, double* @a
  %1 = fcmp one double %tmp.23, 0.000000e+00
  br i1 %1, label %if_then, label %if_else

if_then:                                          ; preds = %0
  br label %if_endif

if_else:                                          ; preds = %0
  br label %if_endif

if_endif:                                         ; preds = %if_else, %if_then
  %iftmp = phi double [ 3.000000e+00, %if_then ], [ 4.000000e+00, %if_else ]
  %tmp.25 = load double, double* @a
  %tmp.26 = fsub double %tmp.25, 6.000000e+00
  %tmp.27 = load double, double* @a
  %2 = fcmp one double %tmp.27, 0.000000e+00
  br i1 %2, label %if_then1, label %if_else2

if_then1:                                         ; preds = %if_endif
  br label %if_endif3

if_else2:                                         ; preds = %if_endif
  br label %if_endif3

if_endif3:                                        ; preds = %if_else2, %if_then1
  %iftmp4 = phi double [ 5.000000e+00, %if_then1 ], [ 2.000000e+00, %if_else2 ]
  br i1 true, label %if_then5, label %if_else6

if_then5:                                         ; preds = %if_endif3
  br label %if_endif7

if_else6:                                         ; preds = %if_endif3
  br label %if_endif7

if_endif7:                                        ; preds = %if_else6, %if_then5
  %iftmp8 = phi double [ 5.000000e+00, %if_then5 ], [ 1.100000e+01, %if_else6 ]
  br i1 false, label %if_then9, label %if_cond

if_then9:                                         ; preds = %if_endif7
  br label %if_endif12

if_cond:                                          ; preds = %if_endif7
  br i1 true, label %if_then10, label %if_else11

if_then10:                                        ; preds = %if_cond
  br label %if_endif12

if_else11:                                        ; preds = %if_cond
  br label %if_endif12

if_endif12:                                       ; preds = %if_else11, %if_then10, %if_then9
  %iftmp13 = phi double [ 0.000000e+00, %if_then9 ], [ 1.000000e+00, %if_then10 ], [ 0.000000e+00, %if_else11 ]
  br i1 false, label %if_then14, label %if_cond15

if_then14:                                        ; preds = %if_endif12
  br label %if_endif20

if_cond15:                                        ; preds = %if_endif12
  br i1 true, label %if_then16, label %if_cond17

if_then16:                                        ; preds = %if_cond15
  br label %if_endif20

if_cond17:                                        ; preds = %if_cond15
  br i1 true, label %if_then18, label %if_else19

if_then18:                                        ; preds = %if_cond17
  br label %if_endif20

if_else19:                                        ; preds = %if_cond17
  br label %if_endif20

if_endif20:                                       ; preds = %if_else19, %if_then18, %if_then16, %if_then14
  %iftmp21 = phi double [ 0.000000e+00, %if_then14 ], [ 1.000000e+00, %if_then16 ], [ 2.000000e+00, %if_then18 ], [ 3.000000e+00, %if_else19 ]
  br i1 false, label %if_then22, label %if_else23

if_then22:                                        ; preds = %if_endif20
  br label %if_endif28

if_else23:                                        ; preds = %if_endif20
  %tmp.32 = load double, double* @a
  %3 = fcmp one double %tmp.32, 0.000000e+00
  br i1 %3, label %if_then24, label %if_else25

if_then24:                                        ; preds = %if_else23
  br label %if_endif26

if_else25:                                        ; preds = %if_else23
  br label %if_endif26

if_endif26:                                       ; preds = %if_else25, %if_then24
  %iftmp27 = phi double [ 1.000000e+00, %if_then24 ], [ 2.000000e+00, %if_else25 ]
  br label %if_endif28

if_endif28:                                       ; preds = %if_endif26, %if_then22
  %iftmp29 = phi double [ 0.000000e+00, %if_then22 ], [ %iftmp27, %if_endif26 ]
  %tmp.33 = call double @printc(double 4.200000e+01)
  %tmp.34 = call double @printc(double 1.000000e+01)
  store double 1.000000e+00, double* @a
  br label %for_cmp

for_cmp:                                          ; preds = %for_loop, %if_endif28
  %tmp.43 = load double, double* @a
  %tmp.44 = fcmp ole double %tmp.43, 2.000000e+01
  %4 = uitofp i1 %tmp.44 to double
  %5 = fcmp one double %4, 0.000000e+00
  br i1 %5, label %for_loop, label %for_after_loop

for_loop:                                         ; preds = %for_cmp
  %tmp.45 = call double @printc(double 4.200000e+01)
  %tmp.46 = load double, double* @a
  %tmp.47 = fadd double %tmp.46, 1.000000e+00
  store double %tmp.47, double* @a
  br label %for_cmp

for_after_loop:                                   ; preds = %for_cmp
  %tmp.48 = call double @printc(double 1.000000e+01)
  %tmp.51 = call double @printc(double 4.200000e+01)
  %tmp.52 = call double @printc(double 1.000000e+01)
  %tmp.53 = call double @"binary:"(double %tmp.51, double %tmp.52)
  %tmp.55 = call double @"unary!"(double 3.000000e+00)
  %tmp.56 = call double @"unary!"(double 0.000000e+00)
  store double 4.200000e+01, double* @a
  %tmp.63 = call double @a_function(double 4.200000e+01)
  %tmp.64 = load double, double* @a
  %tmp.65 = call double @printc(double %tmp.64)
  %tmp.66 = load double, double* @a
  %tmp.67 = call double @printc(double %tmp.66)
  %tmp.68 = call double @"binary:"(double %tmp.65, double %tmp.67)
  %tmp.69 = load double, double* @a
  %tmp.70 = fsub double %tmp.69, 3.200000e+01
  %tmp.71 = call double @printc(double %tmp.70)
  %tmp.72 = call double @"binary:"(double %tmp.68, double %tmp.71)
  %tmp.73 = load double, double* @a
  %tmp.74 = fmul double %tmp.73, 5.000000e+00
  ret double %tmp.74
}

declare double @extern_a(double, double)

define double @def_a(double %def_b, double %def_c) {
def_a.entry:
  %def_b1 = alloca double
  store double %def_b, double* %def_b1
  %def_c2 = alloca double
  store double %def_c, double* %def_c2
  %tmp.8 = load double, double* %def_b1
  %tmp.9 = load double, double* %def_c2
  %tmp.10 = fmul double 2.000000e+00, %tmp.9
  %tmp.11 = fadd double %tmp.8, %tmp.10
  %tmp.12 = fsub double %tmp.11, 6.000000e+00
  ret double %tmp.12
}

define double @cse_test(double %x) {
cse_test.entry:
  %x1 = alloca double
  store double %x, double* %x1
  %tmp.14 = load double, double* %x1
  %tmp.15 = fadd double 3.000000e+00, %tmp.14
  %tmp.16 = load double, double* %x1
  %tmp.17 = fadd double %tmp.16, 3.000000e+00
  %tmp.18 = fmul double %tmp.15, %tmp.17
  ret double %tmp.18
}

define double @ta(double %b, double %c) {
ta.entry:
  store double %b, double* @b
  store double %c, double* @c
  %tmp.19 = load double, double* @b
  %tmp.20 = load double, double* @c
  %tmp.21 = fmul double %tmp.19, %tmp.20
  ret double %tmp.21
}

declare double @printc(double)

define double @"binary:"(double %LHS, double %RHS) {
"binary:.entry":
  %LHS1 = alloca double
  store double %LHS, double* %LHS1
  %RHS2 = alloca double
  store double %RHS, double* %RHS2
  %tmp.49 = load double, double* %LHS1
  %tmp.50 = load double, double* %RHS2
  ret double %tmp.50
}

define double @"unary!"(double %RHS) {
"unary!.entry":
  %RHS1 = alloca double
  store double %RHS, double* %RHS1
  %tmp.54 = load double, double* %RHS1
  %0 = fcmp one double %tmp.54, 0.000000e+00
  br i1 %0, label %if_then, label %if_else

if_then:                                          ; preds = %"unary!.entry"
  br label %if_endif

if_else:                                          ; preds = %"unary!.entry"
  br label %if_endif

if_endif:                                         ; preds = %if_else, %if_then
  %iftmp = phi double [ 0.000000e+00, %if_then ], [ 1.000000e+00, %if_else ]
  ret double %iftmp
}

define double @a_function(double %a) {
a_function.entry:
  store double %a, double* @a
  store double 4.200000e+01, double* @a
  %tmp.57 = load double, double* @a
  %tmp.58 = call double @printc(double %tmp.57)
  %tmp.59 = load double, double* @a
  %tmp.60 = fsub double %tmp.59, 3.200000e+01
  %tmp.61 = call double @printc(double %tmp.60)
  %tmp.62 = call double @"binary:"(double %tmp.58, double %tmp.61)
  ret double %tmp.62
}
*
********************
*
*
**
210.000000
>Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, =)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
AssignmentExprAST (Line 1, Column 1): name = a
  NumberExprAST (Line 1, Column 5): val = 0.000000
; ModuleID = 'tmpmodule.1'

@a = internal global double 0.000000e+00

define internal double @__toy_main() {
  store double 0.000000e+00, double* @a
  ret double 0.000000e+00
}
0.000000
Token (TOKEN_IDENTIFIER, b)
Token (TOKEN_LETTER, =)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
AssignmentExprAST (Line 2, Column 1): name = b
  NumberExprAST (Line 2, Column 5): val = 0.000000
; ModuleID = 'tmpmodule.2'

@a = external global double
@b = internal global double 0.000000e+00

define internal double @__toy_main() {
  store double 0.000000e+00, double* @b
  ret double 0.000000e+00
}
0.000000
Token (TOKEN_IDENTIFIER, c)
Token (TOKEN_LETTER, =)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
AssignmentExprAST (Line 3, Column 1): name = c
  NumberExprAST (Line 3, Column 5): val = 0.000000
; ModuleID = 'tmpmodule.3'

@a = external global double
@b = external global double
@c = internal global double 0.000000e+00

define internal double @__toy_main() {
  store double 0.000000e+00, double* @c
  ret double 0.000000e+00
}
0.000000
>Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_OP, *)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 5, Column 3): op = +
  NumberExprAST (Line 5, Column 1): val = 3.000000
  BinaryExprAST (Line 5, Column 7): op = *
    NumberExprAST (Line 5, Column 5): val = 4.000000
    NumberExprAST (Line 5, Column 9): val = 2.000000
; ModuleID = 'tmpmodule.4'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 1.100000e+01
}
11.000000
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, +)
unread Token (TOKEN_OP, +)
Token (TOKEN_OP, +)
unread Token (TOKEN_OP, +)
Token (TOKEN_OP, +)
Token (TOKEN_IDENTIFIER, b)
Token (TOKEN_OP, *)
unread Token (TOKEN_OP, *)
Token (TOKEN_OP, *)
Token (TOKEN_IDENTIFIER, c)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 6, Column 3): op = +
  VariableExprAST (Line 6, Column 1): name = a
  BinaryExprAST (Line 6, Column 7): op = *
    VariableExprAST (Line 6, Column 5): name = b
    VariableExprAST (Line 6, Column 9): name = c
; ModuleID = 'tmpmodule.5'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.3 = load double, double* @a
  %tmp.4 = load double, double* @b
  %tmp.5 = load double, double* @c
  %tmp.6 = fmul double %tmp.4, %tmp.5
  %tmp.7 = fadd double %tmp.3, %tmp.6
  ret double %tmp.7
}
0.000000
>Token (TOKEN_EXTERN)
Token (TOKEN_IDENTIFIER, extern_a)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, extern_b)
Token (TOKEN_LETTER, ,)
Token (TOKEN_IDENTIFIER, extern_c)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
PrototypeAST (Line 8, Column 8): extern_a (extern_b, extern_c)
; ModuleID = 'tmpmodule.6'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 0.000000e+00
}

declare double @extern_a(double, double)
0.000000
>Token (TOKEN_DEF)
Token (TOKEN_IDENTIFIER, def_a)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, def_b)
Token (TOKEN_LETTER, ,)
Token (TOKEN_IDENTIFIER, def_c)
Token (TOKEN_LETTER, ))
Token (TOKEN_IDENTIFIER, def_b)
Token (TOKEN_OP, +)
unread Token (TOKEN_OP, +)
Token (TOKEN_OP, +)
unread Token (TOKEN_OP, +)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_OP, *)
Token (TOKEN_IDENTIFIER, def_c)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
Token (TOKEN_NUMBER, 6.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
FunctionAST (Line 10, Column 1):
  PrototypeAST (Line 10, Column 5): def_a (def_b, def_c)
  BinaryExprAST (Line 11, Column 21): op = -
    BinaryExprAST (Line 11, Column 9): op = +
      VariableExprAST (Line 11, Column 3): name = def_b
      BinaryExprAST (Line 11, Column 13): op = *
        NumberExprAST (Line 11, Column 11): val = 2.000000
        VariableExprAST (Line 11, Column 15): name = def_c
    NumberExprAST (Line 11, Column 23): val = 6.000000
; ModuleID = 'tmpmodule.7'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 0.000000e+00
}

declare double @extern_a(double, double)

define double @def_a(double %def_b, double %def_c) {
def_a.entry:
  %def_b1 = alloca double
  store double %def_b, double* %def_b1
  %def_c2 = alloca double
  store double %def_c, double* %def_c2
  %tmp.8 = load double, double* %def_b1
  %tmp.9 = load double, double* %def_c2
  %tmp.10 = fmul double 2.000000e+00, %tmp.9
  %tmp.11 = fadd double %tmp.8, %tmp.10
  %tmp.12 = fsub double %tmp.11, 6.000000e+00
  ret double %tmp.12
}
0.000000
>Token (TOKEN_IDENTIFIER, def_a)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ,)
unread Token (TOKEN_LETTER, ,)
Token (TOKEN_LETTER, ,)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
CallExprAST (Line 13, Column 1): Callee = def_a
  Arg #0:
    NumberExprAST (Line 13, Column 7): val = 2.000000
  Arg #1:
    NumberExprAST (Line 13, Column 10): val = 4.000000
; ModuleID = 'tmpmodule.8'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.13 = call double @def_a(double 2.000000e+00, double 4.000000e+00)
  ret double %tmp.13
}

declare double @extern_a(double, double)

declare double @def_a(double, double)
4.000000
>Token (TOKEN_DEF)
Token (TOKEN_IDENTIFIER, cse_test)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, x)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_OP, +)
Token (TOKEN_IDENTIFIER, x)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_OP, *)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, x)
Token (TOKEN_OP, +)
unread Token (TOKEN_OP, +)
Token (TOKEN_OP, +)
unread Token (TOKEN_OP, +)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
FunctionAST (Line 17, Column 1):
  PrototypeAST (Line 17, Column 5): cse_test (x)
  BinaryExprAST (Line 17, Column 23): op = *
    BinaryExprAST (Line 17, Column 19): op = +
      NumberExprAST (Line 17, Column 18): val = 3.000000
      VariableExprAST (Line 17, Column 20): name = x
    BinaryExprAST (Line 17, Column 27): op = +
      VariableExprAST (Line 17, Column 26): name = x
      NumberExprAST (Line 17, Column 28): val = 3.000000
; ModuleID = 'tmpmodule.9'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 0.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

define double @cse_test(double %x) {
cse_test.entry:
  %x1 = alloca double
  store double %x, double* %x1
  %tmp.14 = load double, double* %x1
  %tmp.15 = fadd double 3.000000e+00, %tmp.14
  %tmp.16 = load double, double* %x1
  %tmp.17 = fadd double %tmp.16, 3.000000e+00
  %tmp.18 = fmul double %tmp.15, %tmp.17
  ret double %tmp.18
}
0.000000
>Token (TOKEN_DEF)
Token (TOKEN_IDENTIFIER, ta)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, b)
Token (TOKEN_LETTER, ,)
Token (TOKEN_IDENTIFIER, c)
Token (TOKEN_LETTER, ))
Token (TOKEN_IDENTIFIER, b)
Token (TOKEN_OP, *)
unread Token (TOKEN_OP, *)
Token (TOKEN_OP, *)
unread Token (TOKEN_OP, *)
Token (TOKEN_OP, *)
Token (TOKEN_IDENTIFIER, c)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
FunctionAST (Line 19, Column 1):
  PrototypeAST (Line 19, Column 5): ta (b, c)
  BinaryExprAST (Line 19, Column 14): op = *
    VariableExprAST (Line 19, Column 13): name = b
    VariableExprAST (Line 19, Column 15): name = c
; ModuleID = 'tmpmodule.10'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 0.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

define double @ta(double %b, double %c) {
ta.entry:
  store double %b, double* @b
  store double %c, double* @c
  %tmp.19 = load double, double* @b
  %tmp.20 = load double, double* @c
  %tmp.21 = fmul double %tmp.19, %tmp.20
  ret double %tmp.21
}
0.000000
Token (TOKEN_IDENTIFIER, ta)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_LETTER, ,)
unread Token (TOKEN_LETTER, ,)
Token (TOKEN_LETTER, ,)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
CallExprAST (Line 20, Column 1): Callee = ta
  Arg #0:
    NumberExprAST (Line 20, Column 4): val = 3.000000
  Arg #1:
    NumberExprAST (Line 20, Column 6): val = 4.000000
; ModuleID = 'tmpmodule.11'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.22 = call double @ta(double 3.000000e+00, double 4.000000e+00)
  ret double %tmp.22
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)
12.000000
>Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_ELSE)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
IfExprAST (Line 22, Column 1): have 1 CondThenExprs, have 1 ElseExpr
  CondExpr #1
    VariableExprAST (Line 22, Column 5): name = a
  ThenExpr #1
    NumberExprAST (Line 22, Column 8): val = 3.000000
  ElseExpr
    NumberExprAST (Line 22, Column 16): val = 4.000000
; ModuleID = 'tmpmodule.12'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.23 = load double, double* @a
  %1 = fcmp one double %tmp.23, 0.000000e+00
  br i1 %1, label %if_then, label %if_else

if_then:                                          ; preds = %0
  br label %if_endif

if_else:                                          ; preds = %0
  br label %if_endif

if_endif:                                         ; preds = %if_else, %if_then
  %iftmp = phi double [ 3.000000e+00, %if_then ], [ 4.000000e+00, %if_else ]
  ret double %iftmp
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)
4.000000
>Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
Token (TOKEN_NUMBER, 6.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
BlockExprAST (Line 24, Column 1): have 2 exprs
  BinaryExprAST (Line 25, Column 2): op = +
    NumberExprAST (Line 25, Column 1): val = 3.000000
    NumberExprAST (Line 25, Column 3): val = 2.000000
  BinaryExprAST (Line 26, Column 2): op = -
    VariableExprAST (Line 26, Column 1): name = a
    NumberExprAST (Line 26, Column 3): val = 6.000000
; ModuleID = 'tmpmodule.13'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.25 = load double, double* @a
  %tmp.26 = fsub double %tmp.25, 6.000000e+00
  ret double %tmp.26
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)
-6.000000
>Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELSE)
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 7.000000)
Token (TOKEN_OP, -)
Token (TOKEN_NUMBER, 5.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
IfExprAST (Line 29, Column 1): have 1 CondThenExprs, have 1 ElseExpr
  CondExpr #1
    VariableExprAST (Line 29, Column 5): name = a
  ThenExpr #1
    BlockExprAST (Line 29, Column 8): have 1 exprs
      BinaryExprAST (Line 30, Column 4): op = +
        NumberExprAST (Line 30, Column 3): val = 3.000000
        NumberExprAST (Line 30, Column 5): val = 2.000000
  ElseExpr
    BlockExprAST (Line 31, Column 8): have 1 exprs
      BinaryExprAST (Line 32, Column 4): op = -
        NumberExprAST (Line 32, Column 3): val = 7.000000
        NumberExprAST (Line 32, Column 5): val = 5.000000
; ModuleID = 'tmpmodule.14'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.27 = load double, double* @a
  %1 = fcmp one double %tmp.27, 0.000000e+00
  br i1 %1, label %if_then, label %if_else

if_then:                                          ; preds = %0
  br label %if_endif

if_else:                                          ; preds = %0
  br label %if_endif

if_endif:                                         ; preds = %if_else, %if_then
  %iftmp = phi double [ 5.000000e+00, %if_then ], [ 2.000000e+00, %if_else ]
  ret double %iftmp
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)
2.000000
>Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELSE)
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 7.000000)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
IfExprAST (Line 35, Column 1): have 1 CondThenExprs, have 1 ElseExpr
  CondExpr #1
    NumberExprAST (Line 35, Column 5): val = 1.000000
  ThenExpr #1
    BlockExprAST (Line 35, Column 8): have 1 exprs
      BinaryExprAST (Line 36, Column 4): op = +
        NumberExprAST (Line 36, Column 3): val = 4.000000
        NumberExprAST (Line 36, Column 5): val = 1.000000
  ElseExpr
    BlockExprAST (Line 37, Column 8): have 1 exprs
      BinaryExprAST (Line 38, Column 4): op = +
        NumberExprAST (Line 38, Column 3): val = 7.000000
        NumberExprAST (Line 38, Column 5): val = 4.000000
; ModuleID = 'tmpmodule.15'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  br i1 true, label %if_then, label %if_else

if_then:                                          ; preds = %0
  br label %if_endif

if_else:                                          ; preds = %0
  br label %if_endif

if_endif:                                         ; preds = %if_else, %if_then
  %iftmp = phi double [ 5.000000e+00, %if_then ], [ 1.100000e+01, %if_else ]
  ret double %iftmp
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)
5.000000
>Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELIF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_IF)
unread Token (TOKEN_IF)
IfExprAST (Line 41, Column 1): have 2 CondThenExprs, have 0 ElseExpr
  CondExpr #1
    NumberExprAST (Line 41, Column 5): val = 0.000000
  ThenExpr #1
    BlockExprAST (Line 41, Column 8): have 1 exprs
      NumberExprAST (Line 42, Column 3): val = 0.000000
  CondExpr #2
    NumberExprAST (Line 43, Column 9): val = 1.000000
  ThenExpr #2
    BlockExprAST (Line 43, Column 12): have 1 exprs
      NumberExprAST (Line 44, Column 3): val = 1.000000
; ModuleID = 'tmpmodule.16'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  br i1 false, label %if_then, label %if_cond

if_then:                                          ; preds = %0
  br label %if_endif

if_cond:                                          ; preds = %0
  br i1 true, label %if_then1, label %if_else

if_then1:                                         ; preds = %if_cond
  br label %if_endif

if_else:                                          ; preds = %if_cond
  br label %if_endif

if_endif:                                         ; preds = %if_else, %if_then1, %if_then
  %iftmp = phi double [ 0.000000e+00, %if_then ], [ 1.000000e+00, %if_then1 ], [ 0.000000e+00, %if_else ]
  ret double %iftmp
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)
1.000000
Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELIF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELIF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELSE)
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
IfExprAST (Line 47, Column 1): have 3 CondThenExprs, have 1 ElseExpr
  CondExpr #1
    NumberExprAST (Line 47, Column 5): val = 0.000000
  ThenExpr #1
    BlockExprAST (Line 47, Column 8): have 1 exprs
      NumberExprAST (Line 48, Column 3): val = 0.000000
  CondExpr #2
    NumberExprAST (Line 49, Column 9): val = 1.000000
  ThenExpr #2
    BlockExprAST (Line 49, Column 12): have 1 exprs
      NumberExprAST (Line 50, Column 3): val = 1.000000
  CondExpr #3
    NumberExprAST (Line 51, Column 9): val = 2.000000
  ThenExpr #3
    BlockExprAST (Line 51, Column 12): have 1 exprs
      NumberExprAST (Line 52, Column 3): val = 2.000000
  ElseExpr
    BlockExprAST (Line 53, Column 8): have 1 exprs
      NumberExprAST (Line 54, Column 3): val = 3.000000
; ModuleID = 'tmpmodule.17'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  br i1 false, label %if_then, label %if_cond

if_then:                                          ; preds = %0
  br label %if_endif

if_cond:                                          ; preds = %0
  br i1 true, label %if_then1, label %if_cond2

if_then1:                                         ; preds = %if_cond
  br label %if_endif

if_cond2:                                         ; preds = %if_cond
  br i1 true, label %if_then3, label %if_else

if_then3:                                         ; preds = %if_cond2
  br label %if_endif

if_else:                                          ; preds = %if_cond2
  br label %if_endif

if_endif:                                         ; preds = %if_else, %if_then3, %if_then1, %if_then
  %iftmp = phi double [ 0.000000e+00, %if_then ], [ 1.000000e+00, %if_then1 ], [ 2.000000e+00, %if_then3 ], [ 3.000000e+00, %if_else ]
  ret double %iftmp
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)
1.000000
>Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELSE)
Token (TOKEN_LETTER, {)
Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELSE)
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_LETTER, })
IfExprAST (Line 57, Column 1): have 1 CondThenExprs, have 1 ElseExpr
  CondExpr #1
    NumberExprAST (Line 57, Column 5): val = 0.000000
  ThenExpr #1
    BlockExprAST (Line 57, Column 8): have 1 exprs
      NumberExprAST (Line 58, Column 3): val = 0.000000
  ElseExpr
    BlockExprAST (Line 59, Column 8): have 1 exprs
      IfExprAST (Line 60, Column 3): have 1 CondThenExprs, have 1 ElseExpr
        CondExpr #1
          VariableExprAST (Line 60, Column 7): name = a
        ThenExpr #1
          BlockExprAST (Line 60, Column 10): have 1 exprs
            NumberExprAST (Line 61, Column 5): val = 1.000000
        ElseExpr
          BlockExprAST (Line 62, Column 10): have 1 exprs
            NumberExprAST (Line 63, Column 5): val = 2.000000
; ModuleID = 'tmpmodule.18'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  br i1 false, label %if_then, label %if_else

if_then:                                          ; preds = %0
  br label %if_endif3

if_else:                                          ; preds = %0
  %tmp.32 = load double, double* @a
  %1 = fcmp one double %tmp.32, 0.000000e+00
  br i1 %1, label %if_then1, label %if_else2

if_then1:                                         ; preds = %if_else
  br label %if_endif

if_else2:                                         ; preds = %if_else
  br label %if_endif

if_endif:                                         ; preds = %if_else2, %if_then1
  %iftmp = phi double [ 1.000000e+00, %if_then1 ], [ 2.000000e+00, %if_else2 ]
  br label %if_endif3

if_endif3:                                        ; preds = %if_endif, %if_then
  %iftmp4 = phi double [ 0.000000e+00, %if_then ], [ %iftmp, %if_endif ]
  ret double %iftmp4
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)
2.000000
>Token (TOKEN_EXTERN)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, x)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
PrototypeAST (Line 67, Column 8): printc (x)
; ModuleID = 'tmpmodule.19'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 0.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)
0.000000
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
CallExprAST (Line 68, Column 1): Callee = printc
  Arg #0:
    NumberExprAST (Line 68, Column 8): val = 42.000000
; ModuleID = 'tmpmodule.20'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.33 = call double @printc(double 4.200000e+01)
  ret double %tmp.33
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)
*0.000000
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 10.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
CallExprAST (Line 69, Column 1): Callee = printc
  Arg #0:
    NumberExprAST (Line 69, Column 8): val = 10.000000
; ModuleID = 'tmpmodule.21'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.34 = call double @printc(double 1.000000e+01)
  ret double %tmp.34
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

0.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, <)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 70, Column 3): op = <
  NumberExprAST (Line 70, Column 1): val = 1.000000
  NumberExprAST (Line 70, Column 5): val = 2.000000
; ModuleID = 'tmpmodule.22'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 1.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)
1.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, <)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 71, Column 3): op = <
  NumberExprAST (Line 71, Column 1): val = 1.000000
  NumberExprAST (Line 71, Column 5): val = 0.000000
; ModuleID = 'tmpmodule.23'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 0.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)
0.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, <=)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 72, Column 3): op = <=
  NumberExprAST (Line 72, Column 1): val = 1.000000
  NumberExprAST (Line 72, Column 6): val = 1.000000
; ModuleID = 'tmpmodule.24'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 1.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)
1.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, <=)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 73, Column 3): op = <=
  NumberExprAST (Line 73, Column 1): val = 1.000000
  NumberExprAST (Line 73, Column 6): val = 0.000000
; ModuleID = 'tmpmodule.25'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 0.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)
0.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, ==)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 74, Column 3): op = ==
  NumberExprAST (Line 74, Column 1): val = 1.000000
  NumberExprAST (Line 74, Column 6): val = 1.000000
; ModuleID = 'tmpmodule.26'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 1.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)
1.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, !=)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 75, Column 3): op = !=
  NumberExprAST (Line 75, Column 1): val = 1.000000
  NumberExprAST (Line 75, Column 6): val = 2.000000
; ModuleID = 'tmpmodule.27'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 1.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)
1.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, >)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 76, Column 3): op = >
  NumberExprAST (Line 76, Column 1): val = 1.000000
  NumberExprAST (Line 76, Column 5): val = 0.000000
; ModuleID = 'tmpmodule.28'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 1.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)
1.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, >=)
Token (TOKEN_NUMBER, 5.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 77, Column 3): op = >=
  NumberExprAST (Line 77, Column 1): val = 1.000000
  NumberExprAST (Line 77, Column 6): val = 5.000000
; ModuleID = 'tmpmodule.29'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 0.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)
0.000000
>Token (TOKEN_FOR)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, =)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, <=)
unread Token (TOKEN_OP, <=)
Token (TOKEN_OP, <=)
unread Token (TOKEN_OP, <=)
Token (TOKEN_OP, <=)
Token (TOKEN_NUMBER, 20.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, =)
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, +)
unread Token (TOKEN_OP, +)
Token (TOKEN_OP, +)
unread Token (TOKEN_OP, +)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
ForExprAST (Line 79, Column 1):
  InitExpr:
    AssignmentExprAST (Line 79, Column 6): name = a
      NumberExprAST (Line 79, Column 10): val = 1.000000
  CondExpr:
    BinaryExprAST (Line 79, Column 15): op = <=
      VariableExprAST (Line 79, Column 13): name = a
      NumberExprAST (Line 79, Column 18): val = 20.000000
  NextExpr:
    AssignmentExprAST (Line 79, Column 22): name = a
      BinaryExprAST (Line 79, Column 28): op = +
        VariableExprAST (Line 79, Column 26): name = a
        NumberExprAST (Line 79, Column 30): val = 1.000000
  BlockExpr:
    BlockExprAST (Line 79, Column 33): have 1 exprs
      CallExprAST (Line 80, Column 3): Callee = printc
        Arg #0:
          NumberExprAST (Line 80, Column 10): val = 42.000000
; ModuleID = 'tmpmodule.30'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  store double 1.000000e+00, double* @a
  br label %for_cmp

for_cmp:                                          ; preds = %for_loop, %0
  %tmp.43 = load double, double* @a
  %tmp.44 = fcmp ole double %tmp.43, 2.000000e+01
  %1 = uitofp i1 %tmp.44 to double
  %2 = fcmp one double %1, 0.000000e+00
  br i1 %2, label %for_loop, label %for_after_loop

for_loop:                                         ; preds = %for_cmp
  %tmp.45 = call double @printc(double 4.200000e+01)
  %tmp.46 = load double, double* @a
  %tmp.47 = fadd double %tmp.46, 1.000000e+00
  store double %tmp.47, double* @a
  br label %for_cmp

for_after_loop:                                   ; preds = %for_cmp
  ret double 0.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)
********************0.000000
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 10.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
CallExprAST (Line 82, Column 1): Callee = printc
  Arg #0:
    NumberExprAST (Line 82, Column 8): val = 10.000000
; ModuleID = 'tmpmodule.31'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.48 = call double @printc(double 1.000000e+01)
  ret double %tmp.48
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

0.000000
>Token (TOKEN_DEF)
Token (TOKEN_BINARY)
Token (TOKEN_LETTER, :)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, LHS)
Token (TOKEN_LETTER, ,)
Token (TOKEN_IDENTIFIER, RHS)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_IDENTIFIER, LHS)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_IDENTIFIER, RHS)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
FunctionAST (Line 84, Column 1):
  PrototypeAST (Line 84, Column 5): binary: (LHS, RHS)
  BlockExprAST (Line 84, Column 24): have 2 exprs
    VariableExprAST (Line 85, Column 2): name = LHS
    VariableExprAST (Line 86, Column 2): name = RHS
; ModuleID = 'tmpmodule.32'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 0.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

define double @"binary:"(double %LHS, double %RHS) {
"binary:.entry":
  %LHS1 = alloca double
  store double %LHS, double* %LHS1
  %RHS2 = alloca double
  store double %RHS, double* %RHS2
  %tmp.49 = load double, double* %LHS1
  %tmp.50 = load double, double* %RHS2
  ret double %tmp.50
}
0.000000
>Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_OP, :)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 10.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 89, Column 12): op = :
  CallExprAST (Line 89, Column 1): Callee = printc
    Arg #0:
      NumberExprAST (Line 89, Column 8): val = 42.000000
  CallExprAST (Line 89, Column 14): Callee = printc
    Arg #0:
      NumberExprAST (Line 89, Column 21): val = 10.000000
; ModuleID = 'tmpmodule.33'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.51 = call double @printc(double 4.200000e+01)
  %tmp.52 = call double @printc(double 1.000000e+01)
  %tmp.53 = call double @"binary:"(double %tmp.51, double %tmp.52)
  ret double %tmp.53
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

declare double @"binary:"(double, double)
*
0.000000
>Token (TOKEN_DEF)
Token (TOKEN_UNARY)
Token (TOKEN_LETTER, !)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, RHS)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, RHS)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_ELSE)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
FunctionAST (Line 91, Column 1):
  PrototypeAST (Line 91, Column 5): unary! (RHS)
  BlockExprAST (Line 91, Column 18): have 1 exprs
    IfExprAST (Line 92, Column 3): have 1 CondThenExprs, have 1 ElseExpr
      CondExpr #1
        VariableExprAST (Line 92, Column 7): name = RHS
      ThenExpr #1
        NumberExprAST (Line 92, Column 12): val = 0.000000
      ElseExpr
        NumberExprAST (Line 92, Column 20): val = 1.000000
; ModuleID = 'tmpmodule.34'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 0.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

declare double @"binary:"(double, double)

define double @"unary!"(double %RHS) {
"unary!.entry":
  %RHS1 = alloca double
  store double %RHS, double* %RHS1
  %tmp.54 = load double, double* %RHS1
  %0 = fcmp one double %tmp.54, 0.000000e+00
  br i1 %0, label %if_then, label %if_else

if_then:                                          ; preds = %"unary!.entry"
  br label %if_endif

if_else:                                          ; preds = %"unary!.entry"
  br label %if_endif

if_endif:                                         ; preds = %if_else, %if_then
  %iftmp = phi double [ 0.000000e+00, %if_then ], [ 1.000000e+00, %if_else ]
  ret double %iftmp
}
0.000000
>Token (TOKEN_OP, !)
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
UnaryExprAST (Line 95, Column 1): op = !
  NumberExprAST (Line 95, Column 2): val = 3.000000
; ModuleID = 'tmpmodule.35'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.55 = call double @"unary!"(double 3.000000e+00)
  ret double %tmp.55
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

declare double @"binary:"(double, double)

declare double @"unary!"(double)
0.000000
Token (TOKEN_OP, !)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
UnaryExprAST (Line 96, Column 1): op = !
  NumberExprAST (Line 96, Column 2): val = 0.000000
; ModuleID = 'tmpmodule.36'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.56 = call double @"unary!"(double 0.000000e+00)
  ret double %tmp.56
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

declare double @"binary:"(double, double)

declare double @"unary!"(double)
1.000000
>Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, =)
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
AssignmentExprAST (Line 98, Column 1): name = a
  NumberExprAST (Line 98, Column 5): val = 42.000000
; ModuleID = 'tmpmodule.37'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  store double 4.200000e+01, double* @a
  ret double 4.200000e+01
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

declare double @"binary:"(double, double)

declare double @"unary!"(double)
42.000000
Token (TOKEN_DEF)
Token (TOKEN_IDENTIFIER, a_function)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, =)
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_OP, :)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
Token (TOKEN_NUMBER, 32.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
FunctionAST (Line 99, Column 1):
  PrototypeAST (Line 99, Column 5): a_function (a)
  BlockExprAST (Line 99, Column 19): have 2 exprs
    AssignmentExprAST (Line 100, Column 3): name = a
      NumberExprAST (Line 100, Column 7): val = 42.000000
    BinaryExprAST (Line 101, Column 13): op = :
      CallExprAST (Line 101, Column 3): Callee = printc
        Arg #0:
          VariableExprAST (Line 101, Column 10): name = a
      CallExprAST (Line 101, Column 15): Callee = printc
        Arg #0:
          BinaryExprAST (Line 101, Column 24): op = -
            VariableExprAST (Line 101, Column 22): name = a
            NumberExprAST (Line 101, Column 26): val = 32.000000
; ModuleID = 'tmpmodule.38'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 0.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

declare double @"binary:"(double, double)

declare double @"unary!"(double)

define double @a_function(double %a) {
a_function.entry:
  store double %a, double* @a
  store double 4.200000e+01, double* @a
  %tmp.57 = load double, double* @a
  %tmp.58 = call double @printc(double %tmp.57)
  %tmp.59 = load double, double* @a
  %tmp.60 = fsub double %tmp.59, 3.200000e+01
  %tmp.61 = call double @printc(double %tmp.60)
  %tmp.62 = call double @"binary:"(double %tmp.58, double %tmp.61)
  ret double %tmp.62
}
0.000000
>Token (TOKEN_IDENTIFIER, a_function)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
CallExprAST (Line 104, Column 1): Callee = a_function
  Arg #0:
    NumberExprAST (Line 104, Column 12): val = 42.000000
; ModuleID = 'tmpmodule.39'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.63 = call double @a_function(double 4.200000e+01)
  ret double %tmp.63
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

declare double @"binary:"(double, double)

declare double @"unary!"(double)

declare double @a_function(double)
*
0.000000
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_OP, :)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_OP, :)
unread Token (TOKEN_OP, :)
Token (TOKEN_OP, :)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
Token (TOKEN_NUMBER, 32.000000)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 105, Column 23): op = :
  BinaryExprAST (Line 105, Column 11): op = :
    CallExprAST (Line 105, Column 1): Callee = printc
      Arg #0:
        VariableExprAST (Line 105, Column 8): name = a
    CallExprAST (Line 105, Column 13): Callee = printc
      Arg #0:
        VariableExprAST (Line 105, Column 20): name = a
  CallExprAST (Line 105, Column 25): Callee = printc
    Arg #0:
      BinaryExprAST (Line 105, Column 34): op = -
        VariableExprAST (Line 105, Column 32): name = a
        NumberExprAST (Line 105, Column 36): val = 32.000000
; ModuleID = 'tmpmodule.40'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.64 = load double, double* @a
  %tmp.65 = call double @printc(double %tmp.64)
  %tmp.66 = load double, double* @a
  %tmp.67 = call double @printc(double %tmp.66)
  %tmp.68 = call double @"binary:"(double %tmp.65, double %tmp.67)
  %tmp.69 = load double, double* @a
  %tmp.70 = fsub double %tmp.69, 3.200000e+01
  %tmp.71 = call double @printc(double %tmp.70)
  %tmp.72 = call double @"binary:"(double %tmp.68, double %tmp.71)
  ret double %tmp.72
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

declare double @"binary:"(double, double)

declare double @"unary!"(double)

declare double @a_function(double)
**
0.000000
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, *)
unread Token (TOKEN_OP, *)
Token (TOKEN_OP, *)
unread Token (TOKEN_OP, *)
Token (TOKEN_OP, *)
Token (TOKEN_NUMBER, 5.000000)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
BinaryExprAST (Line 106, Column 3): op = *
  VariableExprAST (Line 106, Column 1): name = a
  NumberExprAST (Line 106, Column 5): val = 5.000000
; ModuleID = 'tmpmodule.41'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.73 = load double, double* @a
  %tmp.74 = fmul double %tmp.73, 5.000000e+00
  ret double %tmp.74
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

declare double @"binary:"(double, double)

declare double @"unary!"(double)

declare double @a_function(double)
210.000000
Token (TOKEN_EOF)

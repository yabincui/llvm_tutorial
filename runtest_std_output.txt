Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_OP, *)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
BinaryExprAST op = +
  NumberExprAST val = 3.000000
  BinaryExprAST op = *
    NumberExprAST val = 4.000000
    NumberExprAST val = 2.000000
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, +)
unread Token (TOKEN_OP, +)
Token (TOKEN_OP, +)
Token (TOKEN_IDENTIFIER, b)
Token (TOKEN_OP, *)
Token (TOKEN_IDENTIFIER, c)
Token (TOKEN_LETTER, ;)
BinaryExprAST op = +
  VariableExprAST name = a
  BinaryExprAST op = *
    VariableExprAST name = b
    VariableExprAST name = c
Token (TOKEN_EXTERN)
Token (TOKEN_IDENTIFIER, extern_a)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, extern_b)
Token (TOKEN_LETTER, ,)
Token (TOKEN_IDENTIFIER, extern_c)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
PrototypeAST extern_a (extern_b, extern_c)
Token (TOKEN_DEF)
Token (TOKEN_IDENTIFIER, def_a)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, def_b)
Token (TOKEN_LETTER, ,)
Token (TOKEN_IDENTIFIER, def_c)
Token (TOKEN_LETTER, ))
Token (TOKEN_IDENTIFIER, def_b)
Token (TOKEN_OP, +)
unread Token (TOKEN_OP, +)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_OP, *)
Token (TOKEN_IDENTIFIER, def_c)
Token (TOKEN_OP, -)
Token (TOKEN_NUMBER, 6.000000)
Token (TOKEN_LETTER, ;)
FunctionAST
  PrototypeAST def_a (def_b, def_c)
  BinaryExprAST op = -
    BinaryExprAST op = +
      VariableExprAST name = def_b
      BinaryExprAST op = *
        NumberExprAST val = 2.000000
        VariableExprAST name = def_c
    NumberExprAST val = 6.000000
Token (TOKEN_IDENTIFIER, def_a)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ,)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
CallExprAST Callee = def_a
  Arg #0:
    NumberExprAST val = 2.000000
  Arg #1:
    NumberExprAST val = 4.000000
Token (TOKEN_DEF)
Token (TOKEN_IDENTIFIER, cse_test)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, x)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_OP, +)
Token (TOKEN_IDENTIFIER, x)
Token (TOKEN_LETTER, ))
Token (TOKEN_OP, *)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, x)
Token (TOKEN_OP, +)
unread Token (TOKEN_OP, +)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
FunctionAST
  PrototypeAST cse_test (x)
  BinaryExprAST op = *
    BinaryExprAST op = +
      NumberExprAST val = 3.000000
      VariableExprAST name = x
    BinaryExprAST op = +
      VariableExprAST name = x
      NumberExprAST val = 3.000000
Token (TOKEN_DEF)
Token (TOKEN_IDENTIFIER, ta)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, b)
Token (TOKEN_LETTER, ,)
Token (TOKEN_IDENTIFIER, c)
Token (TOKEN_LETTER, ))
Token (TOKEN_IDENTIFIER, b)
Token (TOKEN_OP, *)
unread Token (TOKEN_OP, *)
Token (TOKEN_OP, *)
Token (TOKEN_IDENTIFIER, c)
Token (TOKEN_LETTER, ;)
FunctionAST
  PrototypeAST ta (b, c)
  BinaryExprAST op = *
    VariableExprAST name = b
    VariableExprAST name = c
Token (TOKEN_IDENTIFIER, ta)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_LETTER, ,)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
CallExprAST Callee = ta
  Arg #0:
    NumberExprAST val = 3.000000
  Arg #1:
    NumberExprAST val = 4.000000
Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_ELSE)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_LETTER, ;)
IfExprAST: have 1 CondThenExprs, have 1 ElseExpr
  CondExpr #1
    VariableExprAST name = a
  ThenExpr #1
    NumberExprAST val = 3.000000
  ElseExpr
    NumberExprAST val = 4.000000
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
Token (TOKEN_NUMBER, 6.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
BlockExprAST: have 2 exprs
  BinaryExprAST op = +
    NumberExprAST val = 3.000000
    NumberExprAST val = 2.000000
  BinaryExprAST op = -
    VariableExprAST name = a
    NumberExprAST val = 6.000000
Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELSE)
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 7.000000)
Token (TOKEN_OP, -)
Token (TOKEN_NUMBER, 5.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
IfExprAST: have 1 CondThenExprs, have 1 ElseExpr
  CondExpr #1
    VariableExprAST name = a
  ThenExpr #1
    BlockExprAST: have 1 exprs
      BinaryExprAST op = +
        NumberExprAST val = 3.000000
        NumberExprAST val = 2.000000
  ElseExpr
    BlockExprAST: have 1 exprs
      BinaryExprAST op = -
        NumberExprAST val = 7.000000
        NumberExprAST val = 5.000000
Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELSE)
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 7.000000)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
IfExprAST: have 1 CondThenExprs, have 1 ElseExpr
  CondExpr #1
    NumberExprAST val = 1.000000
  ThenExpr #1
    BlockExprAST: have 1 exprs
      BinaryExprAST op = +
        NumberExprAST val = 4.000000
        NumberExprAST val = 1.000000
  ElseExpr
    BlockExprAST: have 1 exprs
      BinaryExprAST op = +
        NumberExprAST val = 7.000000
        NumberExprAST val = 4.000000
Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELIF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_IF)
unread Token (TOKEN_IF)
IfExprAST: have 2 CondThenExprs, have 0 ElseExpr
  CondExpr #1
    NumberExprAST val = 0.000000
  ThenExpr #1
    BlockExprAST: have 1 exprs
      NumberExprAST val = 0.000000
  CondExpr #2
    NumberExprAST val = 1.000000
  ThenExpr #2
    BlockExprAST: have 1 exprs
      NumberExprAST val = 1.000000
Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELIF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELIF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELSE)
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
IfExprAST: have 3 CondThenExprs, have 1 ElseExpr
  CondExpr #1
    NumberExprAST val = 0.000000
  ThenExpr #1
    BlockExprAST: have 1 exprs
      NumberExprAST val = 0.000000
  CondExpr #2
    NumberExprAST val = 1.000000
  ThenExpr #2
    BlockExprAST: have 1 exprs
      NumberExprAST val = 1.000000
  CondExpr #3
    NumberExprAST val = 2.000000
  ThenExpr #3
    BlockExprAST: have 1 exprs
      NumberExprAST val = 2.000000
  ElseExpr
    BlockExprAST: have 1 exprs
      NumberExprAST val = 3.000000
Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELSE)
Token (TOKEN_LETTER, {)
Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELSE)
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_LETTER, })
IfExprAST: have 1 CondThenExprs, have 1 ElseExpr
  CondExpr #1
    NumberExprAST val = 0.000000
  ThenExpr #1
    BlockExprAST: have 1 exprs
      NumberExprAST val = 0.000000
  ElseExpr
    BlockExprAST: have 1 exprs
      IfExprAST: have 1 CondThenExprs, have 1 ElseExpr
        CondExpr #1
          VariableExprAST name = a
        ThenExpr #1
          BlockExprAST: have 1 exprs
            NumberExprAST val = 1.000000
        ElseExpr
          BlockExprAST: have 1 exprs
            NumberExprAST val = 2.000000
Token (TOKEN_EXTERN)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, x)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
PrototypeAST printc (x)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
CallExprAST Callee = printc
  Arg #0:
    NumberExprAST val = 42.000000
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 10.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
CallExprAST Callee = printc
  Arg #0:
    NumberExprAST val = 10.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, <)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
BinaryExprAST op = <
  NumberExprAST val = 1.000000
  NumberExprAST val = 2.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, <)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
BinaryExprAST op = <
  NumberExprAST val = 1.000000
  NumberExprAST val = 0.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, <=)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
BinaryExprAST op = <=
  NumberExprAST val = 1.000000
  NumberExprAST val = 1.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, <=)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
BinaryExprAST op = <=
  NumberExprAST val = 1.000000
  NumberExprAST val = 0.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, ==)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
BinaryExprAST op = ==
  NumberExprAST val = 1.000000
  NumberExprAST val = 1.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, !=)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
BinaryExprAST op = !=
  NumberExprAST val = 1.000000
  NumberExprAST val = 2.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, >)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
BinaryExprAST op = >
  NumberExprAST val = 1.000000
  NumberExprAST val = 0.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, >=)
Token (TOKEN_NUMBER, 5.000000)
Token (TOKEN_LETTER, ;)
BinaryExprAST op = >=
  NumberExprAST val = 1.000000
  NumberExprAST val = 5.000000
Token (TOKEN_FOR)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, =)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ,)
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, <=)
unread Token (TOKEN_OP, <=)
Token (TOKEN_OP, <=)
Token (TOKEN_NUMBER, 20.000000)
Token (TOKEN_LETTER, ,)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
ForExprAST: VarName = a
  InitExpr:
    NumberExprAST val = 1.000000
  CondExpr:
    BinaryExprAST op = <=
      VariableExprAST name = a
      NumberExprAST val = 20.000000
  StepExpr:
    NumberExprAST val = 1.000000
  BlockExpr:
    BlockExprAST: have 1 exprs
      CallExprAST Callee = printc
        Arg #0:
          NumberExprAST val = 42.000000
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 10.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
CallExprAST Callee = printc
  Arg #0:
    NumberExprAST val = 10.000000
Token (TOKEN_DEF)
Token (TOKEN_BINARY)
Token (TOKEN_LETTER, :)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, LHS)
Token (TOKEN_LETTER, ,)
Token (TOKEN_IDENTIFIER, RHS)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_IDENTIFIER, LHS)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_IDENTIFIER, RHS)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
FunctionAST
  PrototypeAST binary: (LHS, RHS)
  BlockExprAST: have 2 exprs
    VariableExprAST name = LHS
    VariableExprAST name = RHS
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_OP, :)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 10.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
BinaryExprAST op = :
  CallExprAST Callee = printc
    Arg #0:
      NumberExprAST val = 42.000000
  CallExprAST Callee = printc
    Arg #0:
      NumberExprAST val = 10.000000
Token (TOKEN_DEF)
Token (TOKEN_UNARY)
Token (TOKEN_LETTER, !)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, RHS)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, RHS)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_ELSE)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
FunctionAST
  PrototypeAST unary! (RHS)
  BlockExprAST: have 1 exprs
    IfExprAST: have 1 CondThenExprs, have 1 ElseExpr
      CondExpr #1
        VariableExprAST name = RHS
      ThenExpr #1
        NumberExprAST val = 0.000000
      ElseExpr
        NumberExprAST val = 1.000000
Token (TOKEN_OP, !)
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_LETTER, ;)
UnaryExprAST op = !
  NumberExprAST val = 3.000000
Token (TOKEN_OP, !)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
UnaryExprAST op = !
  NumberExprAST val = 0.000000
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, =)
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ;)
AssignmentExprAST name = a
  NumberExprAST val = 42.000000
Token (TOKEN_DEF)
Token (TOKEN_IDENTIFIER, a_function)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, =)
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_OP, :)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
Token (TOKEN_NUMBER, 32.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
FunctionAST
  PrototypeAST a_function (a)
  BlockExprAST: have 2 exprs
    AssignmentExprAST name = a
      NumberExprAST val = 42.000000
    BinaryExprAST op = :
      CallExprAST Callee = printc
        Arg #0:
          VariableExprAST name = a
      CallExprAST Callee = printc
        Arg #0:
          BinaryExprAST op = -
            VariableExprAST name = a
            NumberExprAST val = 32.000000
Token (TOKEN_IDENTIFIER, a_function)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
CallExprAST Callee = a_function
  Arg #0:
    NumberExprAST val = 42.000000
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_OP, :)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_OP, :)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
Token (TOKEN_NUMBER, 32.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
BinaryExprAST op = :
  BinaryExprAST op = :
    CallExprAST Callee = printc
      Arg #0:
        VariableExprAST name = a
    CallExprAST Callee = printc
      Arg #0:
        VariableExprAST name = a
  CallExprAST Callee = printc
    Arg #0:
      BinaryExprAST op = -
        VariableExprAST name = a
        NumberExprAST val = 32.000000
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, *)
unread Token (TOKEN_OP, *)
Token (TOKEN_OP, *)
Token (TOKEN_NUMBER, 5.000000)
Token (TOKEN_LETTER, ;)
BinaryExprAST op = *
  VariableExprAST name = a
  NumberExprAST val = 5.000000
Token (TOKEN_EOF)
; ModuleID = 'tmpmodule.1'

@a = internal global double 0.000000e+00
@b = internal global double 0.000000e+00
@c = internal global double 0.000000e+00

define internal double @__toy_main() {
  %tmp.3 = load double, double* @a
  %tmp.4 = load double, double* @b
  %tmp.5 = load double, double* @c
  %tmp.6 = fmul double %tmp.4, %tmp.5
  %tmp.7 = fadd double %tmp.3, %tmp.6
  %tmp.13 = call double @def_a(double 2.000000e+00, double 4.000000e+00)
  %tmp.22 = call double @ta(double 3.000000e+00, double 4.000000e+00)
  %tmp.23 = load double, double* @a
  %1 = fcmp one double %tmp.23, 0.000000e+00
  br i1 %1, label %if_then, label %if_else

if_then:                                          ; preds = %0
  br label %if_endif

if_else:                                          ; preds = %0
  br label %if_endif

if_endif:                                         ; preds = %if_else, %if_then
  %iftmp = phi double [ 3.000000e+00, %if_then ], [ 4.000000e+00, %if_else ]
  %tmp.25 = load double, double* @a
  %tmp.26 = fsub double %tmp.25, 6.000000e+00
  %tmp.27 = load double, double* @a
  %2 = fcmp one double %tmp.27, 0.000000e+00
  br i1 %2, label %if_then1, label %if_else2

if_then1:                                         ; preds = %if_endif
  br label %if_endif3

if_else2:                                         ; preds = %if_endif
  br label %if_endif3

if_endif3:                                        ; preds = %if_else2, %if_then1
  %iftmp4 = phi double [ 5.000000e+00, %if_then1 ], [ 2.000000e+00, %if_else2 ]
  br i1 true, label %if_then5, label %if_else6

if_then5:                                         ; preds = %if_endif3
  br label %if_endif7

if_else6:                                         ; preds = %if_endif3
  br label %if_endif7

if_endif7:                                        ; preds = %if_else6, %if_then5
  %iftmp8 = phi double [ 5.000000e+00, %if_then5 ], [ 1.100000e+01, %if_else6 ]
  br i1 false, label %if_then9, label %if_cond

if_then9:                                         ; preds = %if_endif7
  br label %if_endif12

if_cond:                                          ; preds = %if_endif7
  br i1 true, label %if_then10, label %if_else11

if_then10:                                        ; preds = %if_cond
  br label %if_endif12

if_else11:                                        ; preds = %if_cond
  br label %if_endif12

if_endif12:                                       ; preds = %if_else11, %if_then10, %if_then9
  %iftmp13 = phi double [ 0.000000e+00, %if_then9 ], [ 1.000000e+00, %if_then10 ], [ 0.000000e+00, %if_else11 ]
  br i1 false, label %if_then14, label %if_cond15

if_then14:                                        ; preds = %if_endif12
  br label %if_endif20

if_cond15:                                        ; preds = %if_endif12
  br i1 true, label %if_then16, label %if_cond17

if_then16:                                        ; preds = %if_cond15
  br label %if_endif20

if_cond17:                                        ; preds = %if_cond15
  br i1 true, label %if_then18, label %if_else19

if_then18:                                        ; preds = %if_cond17
  br label %if_endif20

if_else19:                                        ; preds = %if_cond17
  br label %if_endif20

if_endif20:                                       ; preds = %if_else19, %if_then18, %if_then16, %if_then14
  %iftmp21 = phi double [ 0.000000e+00, %if_then14 ], [ 1.000000e+00, %if_then16 ], [ 2.000000e+00, %if_then18 ], [ 3.000000e+00, %if_else19 ]
  br i1 false, label %if_then22, label %if_else23

if_then22:                                        ; preds = %if_endif20
  br label %if_endif28

if_else23:                                        ; preds = %if_endif20
  %tmp.32 = load double, double* @a
  %3 = fcmp one double %tmp.32, 0.000000e+00
  br i1 %3, label %if_then24, label %if_else25

if_then24:                                        ; preds = %if_else23
  br label %if_endif26

if_else25:                                        ; preds = %if_else23
  br label %if_endif26

if_endif26:                                       ; preds = %if_else25, %if_then24
  %iftmp27 = phi double [ 1.000000e+00, %if_then24 ], [ 2.000000e+00, %if_else25 ]
  br label %if_endif28

if_endif28:                                       ; preds = %if_endif26, %if_then22
  %iftmp29 = phi double [ 0.000000e+00, %if_then22 ], [ %iftmp27, %if_endif26 ]
  %tmp.33 = call double @printc(double 4.200000e+01)
  %tmp.34 = call double @printc(double 1.000000e+01)
  store double 1.000000e+00, double* @a
  br label %for_cmp

for_cmp:                                          ; preds = %for_loop, %if_endif28
  %tmp.43 = load double, double* @a
  %tmp.44 = fcmp ole double %tmp.43, 2.000000e+01
  %4 = uitofp i1 %tmp.44 to double
  %5 = fcmp one double %4, 0.000000e+00
  br i1 %5, label %for_loop, label %for_after_loop

for_loop:                                         ; preds = %for_cmp
  %tmp.45 = call double @printc(double 4.200000e+01)
  %6 = load double, double* @a
  %7 = fadd double %6, 1.000000e+00
  store double %7, double* @a
  br label %for_cmp

for_after_loop:                                   ; preds = %for_cmp
  %8 = load double, double* @a
  %tmp.46 = call double @printc(double 1.000000e+01)
  %tmp.49 = call double @printc(double 4.200000e+01)
  %tmp.50 = call double @printc(double 1.000000e+01)
  %tmp.51 = call double @"binary:"(double %tmp.49, double %tmp.50)
  %tmp.53 = call double @"unary!"(double 3.000000e+00)
  %tmp.54 = call double @"unary!"(double 0.000000e+00)
  store double 4.200000e+01, double* @a
  %tmp.61 = call double @a_function(double 4.200000e+01)
  %tmp.62 = load double, double* @a
  %tmp.63 = call double @printc(double %tmp.62)
  %tmp.64 = load double, double* @a
  %tmp.65 = call double @printc(double %tmp.64)
  %tmp.66 = call double @"binary:"(double %tmp.63, double %tmp.65)
  %tmp.67 = load double, double* @a
  %tmp.68 = fsub double %tmp.67, 3.200000e+01
  %tmp.69 = call double @printc(double %tmp.68)
  %tmp.70 = call double @"binary:"(double %tmp.66, double %tmp.69)
  %tmp.71 = load double, double* @a
  %tmp.72 = fmul double %tmp.71, 5.000000e+00
  ret double %tmp.72
}

declare double @extern_a(double, double)

define double @def_a(double %def_b, double %def_c) {
def_a.entry:
  %def_b1 = alloca double
  store double %def_b, double* %def_b1
  %def_c2 = alloca double
  store double %def_c, double* %def_c2
  %tmp.8 = load double, double* %def_b1
  %tmp.9 = load double, double* %def_c2
  %tmp.10 = fmul double 2.000000e+00, %tmp.9
  %tmp.11 = fadd double %tmp.8, %tmp.10
  %tmp.12 = fsub double %tmp.11, 6.000000e+00
  ret double %tmp.12
}

define double @cse_test(double %x) {
cse_test.entry:
  %x1 = alloca double
  store double %x, double* %x1
  %tmp.14 = load double, double* %x1
  %tmp.15 = fadd double 3.000000e+00, %tmp.14
  %tmp.16 = load double, double* %x1
  %tmp.17 = fadd double %tmp.16, 3.000000e+00
  %tmp.18 = fmul double %tmp.15, %tmp.17
  ret double %tmp.18
}

define double @ta(double %b, double %c) {
ta.entry:
  store double %b, double* @b
  store double %c, double* @c
  %tmp.19 = load double, double* @b
  %tmp.20 = load double, double* @c
  %tmp.21 = fmul double %tmp.19, %tmp.20
  ret double %tmp.21
}

declare double @printc(double)

define double @"binary:"(double %LHS, double %RHS) {
"binary:.entry":
  %LHS1 = alloca double
  store double %LHS, double* %LHS1
  %RHS2 = alloca double
  store double %RHS, double* %RHS2
  %tmp.47 = load double, double* %LHS1
  %tmp.48 = load double, double* %RHS2
  ret double %tmp.48
}

define double @"unary!"(double %RHS) {
"unary!.entry":
  %RHS1 = alloca double
  store double %RHS, double* %RHS1
  %tmp.52 = load double, double* %RHS1
  %0 = fcmp one double %tmp.52, 0.000000e+00
  br i1 %0, label %if_then, label %if_else

if_then:                                          ; preds = %"unary!.entry"
  br label %if_endif

if_else:                                          ; preds = %"unary!.entry"
  br label %if_endif

if_endif:                                         ; preds = %if_else, %if_then
  %iftmp = phi double [ 0.000000e+00, %if_then ], [ 1.000000e+00, %if_else ]
  ret double %iftmp
}

define double @a_function(double %a) {
a_function.entry:
  store double %a, double* @a
  store double 4.200000e+01, double* @a
  %tmp.55 = load double, double* @a
  %tmp.56 = call double @printc(double %tmp.55)
  %tmp.57 = load double, double* @a
  %tmp.58 = fsub double %tmp.57, 3.200000e+01
  %tmp.59 = call double @printc(double %tmp.58)
  %tmp.60 = call double @"binary:"(double %tmp.56, double %tmp.59)
  ret double %tmp.60
}
*
********************
*
*
**
210.000000
>Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_OP, *)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
BinaryExprAST op = +
  NumberExprAST val = 3.000000
  BinaryExprAST op = *
    NumberExprAST val = 4.000000
    NumberExprAST val = 2.000000
; ModuleID = 'tmpmodule.1'

define internal double @__toy_main() {
  ret double 1.100000e+01
}
11.000000
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, +)
unread Token (TOKEN_OP, +)
Token (TOKEN_OP, +)
Token (TOKEN_IDENTIFIER, b)
Token (TOKEN_OP, *)
Token (TOKEN_IDENTIFIER, c)
Token (TOKEN_LETTER, ;)
BinaryExprAST op = +
  VariableExprAST name = a
  BinaryExprAST op = *
    VariableExprAST name = b
    VariableExprAST name = c
; ModuleID = 'tmpmodule.2'

@a = internal global double 0.000000e+00
@b = internal global double 0.000000e+00
@c = internal global double 0.000000e+00

define internal double @__toy_main() {
  %tmp.3 = load double, double* @a
  %tmp.4 = load double, double* @b
  %tmp.5 = load double, double* @c
  %tmp.6 = fmul double %tmp.4, %tmp.5
  %tmp.7 = fadd double %tmp.3, %tmp.6
  ret double %tmp.7
}
0.000000
>Token (TOKEN_EXTERN)
Token (TOKEN_IDENTIFIER, extern_a)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, extern_b)
Token (TOKEN_LETTER, ,)
Token (TOKEN_IDENTIFIER, extern_c)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
PrototypeAST extern_a (extern_b, extern_c)
; ModuleID = 'tmpmodule.3'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 0.000000e+00
}

declare double @extern_a(double, double)
0.000000
>Token (TOKEN_DEF)
Token (TOKEN_IDENTIFIER, def_a)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, def_b)
Token (TOKEN_LETTER, ,)
Token (TOKEN_IDENTIFIER, def_c)
Token (TOKEN_LETTER, ))
Token (TOKEN_IDENTIFIER, def_b)
Token (TOKEN_OP, +)
unread Token (TOKEN_OP, +)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_OP, *)
Token (TOKEN_IDENTIFIER, def_c)
Token (TOKEN_OP, -)
Token (TOKEN_NUMBER, 6.000000)
Token (TOKEN_LETTER, ;)
FunctionAST
  PrototypeAST def_a (def_b, def_c)
  BinaryExprAST op = -
    BinaryExprAST op = +
      VariableExprAST name = def_b
      BinaryExprAST op = *
        NumberExprAST val = 2.000000
        VariableExprAST name = def_c
    NumberExprAST val = 6.000000
; ModuleID = 'tmpmodule.4'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 0.000000e+00
}

declare double @extern_a(double, double)

define double @def_a(double %def_b, double %def_c) {
def_a.entry:
  %def_b1 = alloca double
  store double %def_b, double* %def_b1
  %def_c2 = alloca double
  store double %def_c, double* %def_c2
  %tmp.8 = load double, double* %def_b1
  %tmp.9 = load double, double* %def_c2
  %tmp.10 = fmul double 2.000000e+00, %tmp.9
  %tmp.11 = fadd double %tmp.8, %tmp.10
  %tmp.12 = fsub double %tmp.11, 6.000000e+00
  ret double %tmp.12
}
0.000000
>Token (TOKEN_IDENTIFIER, def_a)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ,)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
CallExprAST Callee = def_a
  Arg #0:
    NumberExprAST val = 2.000000
  Arg #1:
    NumberExprAST val = 4.000000
; ModuleID = 'tmpmodule.5'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.13 = call double @def_a(double 2.000000e+00, double 4.000000e+00)
  ret double %tmp.13
}

declare double @extern_a(double, double)

declare double @def_a(double, double)
4.000000
>Token (TOKEN_DEF)
Token (TOKEN_IDENTIFIER, cse_test)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, x)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_OP, +)
Token (TOKEN_IDENTIFIER, x)
Token (TOKEN_LETTER, ))
Token (TOKEN_OP, *)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, x)
Token (TOKEN_OP, +)
unread Token (TOKEN_OP, +)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
FunctionAST
  PrototypeAST cse_test (x)
  BinaryExprAST op = *
    BinaryExprAST op = +
      NumberExprAST val = 3.000000
      VariableExprAST name = x
    BinaryExprAST op = +
      VariableExprAST name = x
      NumberExprAST val = 3.000000
; ModuleID = 'tmpmodule.6'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 0.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

define double @cse_test(double %x) {
cse_test.entry:
  %x1 = alloca double
  store double %x, double* %x1
  %tmp.14 = load double, double* %x1
  %tmp.15 = fadd double 3.000000e+00, %tmp.14
  %tmp.16 = load double, double* %x1
  %tmp.17 = fadd double %tmp.16, 3.000000e+00
  %tmp.18 = fmul double %tmp.15, %tmp.17
  ret double %tmp.18
}
0.000000
>Token (TOKEN_DEF)
Token (TOKEN_IDENTIFIER, ta)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, b)
Token (TOKEN_LETTER, ,)
Token (TOKEN_IDENTIFIER, c)
Token (TOKEN_LETTER, ))
Token (TOKEN_IDENTIFIER, b)
Token (TOKEN_OP, *)
unread Token (TOKEN_OP, *)
Token (TOKEN_OP, *)
Token (TOKEN_IDENTIFIER, c)
Token (TOKEN_LETTER, ;)
FunctionAST
  PrototypeAST ta (b, c)
  BinaryExprAST op = *
    VariableExprAST name = b
    VariableExprAST name = c
; ModuleID = 'tmpmodule.7'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 0.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

define double @ta(double %b, double %c) {
ta.entry:
  store double %b, double* @b
  store double %c, double* @c
  %tmp.19 = load double, double* @b
  %tmp.20 = load double, double* @c
  %tmp.21 = fmul double %tmp.19, %tmp.20
  ret double %tmp.21
}
0.000000
Token (TOKEN_IDENTIFIER, ta)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_LETTER, ,)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
CallExprAST Callee = ta
  Arg #0:
    NumberExprAST val = 3.000000
  Arg #1:
    NumberExprAST val = 4.000000
; ModuleID = 'tmpmodule.8'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.22 = call double @ta(double 3.000000e+00, double 4.000000e+00)
  ret double %tmp.22
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)
12.000000
>Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_ELSE)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_LETTER, ;)
IfExprAST: have 1 CondThenExprs, have 1 ElseExpr
  CondExpr #1
    VariableExprAST name = a
  ThenExpr #1
    NumberExprAST val = 3.000000
  ElseExpr
    NumberExprAST val = 4.000000
; ModuleID = 'tmpmodule.9'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.23 = load double, double* @a
  %1 = fcmp one double %tmp.23, 0.000000e+00
  br i1 %1, label %if_then, label %if_else

if_then:                                          ; preds = %0
  br label %if_endif

if_else:                                          ; preds = %0
  br label %if_endif

if_endif:                                         ; preds = %if_else, %if_then
  %iftmp = phi double [ 3.000000e+00, %if_then ], [ 4.000000e+00, %if_else ]
  ret double %iftmp
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)
4.000000
>Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
Token (TOKEN_NUMBER, 6.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
BlockExprAST: have 2 exprs
  BinaryExprAST op = +
    NumberExprAST val = 3.000000
    NumberExprAST val = 2.000000
  BinaryExprAST op = -
    VariableExprAST name = a
    NumberExprAST val = 6.000000
; ModuleID = 'tmpmodule.10'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.25 = load double, double* @a
  %tmp.26 = fsub double %tmp.25, 6.000000e+00
  ret double %tmp.26
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)
-6.000000
>Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELSE)
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 7.000000)
Token (TOKEN_OP, -)
Token (TOKEN_NUMBER, 5.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
IfExprAST: have 1 CondThenExprs, have 1 ElseExpr
  CondExpr #1
    VariableExprAST name = a
  ThenExpr #1
    BlockExprAST: have 1 exprs
      BinaryExprAST op = +
        NumberExprAST val = 3.000000
        NumberExprAST val = 2.000000
  ElseExpr
    BlockExprAST: have 1 exprs
      BinaryExprAST op = -
        NumberExprAST val = 7.000000
        NumberExprAST val = 5.000000
; ModuleID = 'tmpmodule.11'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.27 = load double, double* @a
  %1 = fcmp one double %tmp.27, 0.000000e+00
  br i1 %1, label %if_then, label %if_else

if_then:                                          ; preds = %0
  br label %if_endif

if_else:                                          ; preds = %0
  br label %if_endif

if_endif:                                         ; preds = %if_else, %if_then
  %iftmp = phi double [ 5.000000e+00, %if_then ], [ 2.000000e+00, %if_else ]
  ret double %iftmp
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)
2.000000
>Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELSE)
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 7.000000)
Token (TOKEN_OP, +)
Token (TOKEN_NUMBER, 4.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
IfExprAST: have 1 CondThenExprs, have 1 ElseExpr
  CondExpr #1
    NumberExprAST val = 1.000000
  ThenExpr #1
    BlockExprAST: have 1 exprs
      BinaryExprAST op = +
        NumberExprAST val = 4.000000
        NumberExprAST val = 1.000000
  ElseExpr
    BlockExprAST: have 1 exprs
      BinaryExprAST op = +
        NumberExprAST val = 7.000000
        NumberExprAST val = 4.000000
; ModuleID = 'tmpmodule.12'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  br i1 true, label %if_then, label %if_else

if_then:                                          ; preds = %0
  br label %if_endif

if_else:                                          ; preds = %0
  br label %if_endif

if_endif:                                         ; preds = %if_else, %if_then
  %iftmp = phi double [ 5.000000e+00, %if_then ], [ 1.100000e+01, %if_else ]
  ret double %iftmp
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)
5.000000
>Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELIF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_IF)
unread Token (TOKEN_IF)
IfExprAST: have 2 CondThenExprs, have 0 ElseExpr
  CondExpr #1
    NumberExprAST val = 0.000000
  ThenExpr #1
    BlockExprAST: have 1 exprs
      NumberExprAST val = 0.000000
  CondExpr #2
    NumberExprAST val = 1.000000
  ThenExpr #2
    BlockExprAST: have 1 exprs
      NumberExprAST val = 1.000000
; ModuleID = 'tmpmodule.13'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  br i1 false, label %if_then, label %if_cond

if_then:                                          ; preds = %0
  br label %if_endif

if_cond:                                          ; preds = %0
  br i1 true, label %if_then1, label %if_else

if_then1:                                         ; preds = %if_cond
  br label %if_endif

if_else:                                          ; preds = %if_cond
  br label %if_endif

if_endif:                                         ; preds = %if_else, %if_then1, %if_then
  %iftmp = phi double [ 0.000000e+00, %if_then ], [ 1.000000e+00, %if_then1 ], [ 0.000000e+00, %if_else ]
  ret double %iftmp
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)
1.000000
Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELIF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELIF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELSE)
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
IfExprAST: have 3 CondThenExprs, have 1 ElseExpr
  CondExpr #1
    NumberExprAST val = 0.000000
  ThenExpr #1
    BlockExprAST: have 1 exprs
      NumberExprAST val = 0.000000
  CondExpr #2
    NumberExprAST val = 1.000000
  ThenExpr #2
    BlockExprAST: have 1 exprs
      NumberExprAST val = 1.000000
  CondExpr #3
    NumberExprAST val = 2.000000
  ThenExpr #3
    BlockExprAST: have 1 exprs
      NumberExprAST val = 2.000000
  ElseExpr
    BlockExprAST: have 1 exprs
      NumberExprAST val = 3.000000
; ModuleID = 'tmpmodule.14'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  br i1 false, label %if_then, label %if_cond

if_then:                                          ; preds = %0
  br label %if_endif

if_cond:                                          ; preds = %0
  br i1 true, label %if_then1, label %if_cond2

if_then1:                                         ; preds = %if_cond
  br label %if_endif

if_cond2:                                         ; preds = %if_cond
  br i1 true, label %if_then3, label %if_else

if_then3:                                         ; preds = %if_cond2
  br label %if_endif

if_else:                                          ; preds = %if_cond2
  br label %if_endif

if_endif:                                         ; preds = %if_else, %if_then3, %if_then1, %if_then
  %iftmp = phi double [ 0.000000e+00, %if_then ], [ 1.000000e+00, %if_then1 ], [ 2.000000e+00, %if_then3 ], [ 3.000000e+00, %if_else ]
  ret double %iftmp
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)
1.000000
>Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELSE)
Token (TOKEN_LETTER, {)
Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_ELSE)
Token (TOKEN_LETTER, {)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
Token (TOKEN_LETTER, })
IfExprAST: have 1 CondThenExprs, have 1 ElseExpr
  CondExpr #1
    NumberExprAST val = 0.000000
  ThenExpr #1
    BlockExprAST: have 1 exprs
      NumberExprAST val = 0.000000
  ElseExpr
    BlockExprAST: have 1 exprs
      IfExprAST: have 1 CondThenExprs, have 1 ElseExpr
        CondExpr #1
          VariableExprAST name = a
        ThenExpr #1
          BlockExprAST: have 1 exprs
            NumberExprAST val = 1.000000
        ElseExpr
          BlockExprAST: have 1 exprs
            NumberExprAST val = 2.000000
; ModuleID = 'tmpmodule.15'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  br i1 false, label %if_then, label %if_else

if_then:                                          ; preds = %0
  br label %if_endif3

if_else:                                          ; preds = %0
  %tmp.32 = load double, double* @a
  %1 = fcmp one double %tmp.32, 0.000000e+00
  br i1 %1, label %if_then1, label %if_else2

if_then1:                                         ; preds = %if_else
  br label %if_endif

if_else2:                                         ; preds = %if_else
  br label %if_endif

if_endif:                                         ; preds = %if_else2, %if_then1
  %iftmp = phi double [ 1.000000e+00, %if_then1 ], [ 2.000000e+00, %if_else2 ]
  br label %if_endif3

if_endif3:                                        ; preds = %if_endif, %if_then
  %iftmp4 = phi double [ 0.000000e+00, %if_then ], [ %iftmp, %if_endif ]
  ret double %iftmp4
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)
2.000000
>Token (TOKEN_EXTERN)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, x)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
PrototypeAST printc (x)
; ModuleID = 'tmpmodule.16'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 0.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)
0.000000
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
CallExprAST Callee = printc
  Arg #0:
    NumberExprAST val = 42.000000
; ModuleID = 'tmpmodule.17'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.33 = call double @printc(double 4.200000e+01)
  ret double %tmp.33
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)
*0.000000
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 10.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
CallExprAST Callee = printc
  Arg #0:
    NumberExprAST val = 10.000000
; ModuleID = 'tmpmodule.18'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.34 = call double @printc(double 1.000000e+01)
  ret double %tmp.34
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

0.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, <)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
BinaryExprAST op = <
  NumberExprAST val = 1.000000
  NumberExprAST val = 2.000000
; ModuleID = 'tmpmodule.19'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 1.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)
1.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, <)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
BinaryExprAST op = <
  NumberExprAST val = 1.000000
  NumberExprAST val = 0.000000
; ModuleID = 'tmpmodule.20'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 0.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)
0.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, <=)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
BinaryExprAST op = <=
  NumberExprAST val = 1.000000
  NumberExprAST val = 1.000000
; ModuleID = 'tmpmodule.21'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 1.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)
1.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, <=)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
BinaryExprAST op = <=
  NumberExprAST val = 1.000000
  NumberExprAST val = 0.000000
; ModuleID = 'tmpmodule.22'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 0.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)
0.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, ==)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
BinaryExprAST op = ==
  NumberExprAST val = 1.000000
  NumberExprAST val = 1.000000
; ModuleID = 'tmpmodule.23'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 1.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)
1.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, !=)
Token (TOKEN_NUMBER, 2.000000)
Token (TOKEN_LETTER, ;)
BinaryExprAST op = !=
  NumberExprAST val = 1.000000
  NumberExprAST val = 2.000000
; ModuleID = 'tmpmodule.24'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 1.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)
1.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, >)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
BinaryExprAST op = >
  NumberExprAST val = 1.000000
  NumberExprAST val = 0.000000
; ModuleID = 'tmpmodule.25'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 1.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)
1.000000
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_OP, >=)
Token (TOKEN_NUMBER, 5.000000)
Token (TOKEN_LETTER, ;)
BinaryExprAST op = >=
  NumberExprAST val = 1.000000
  NumberExprAST val = 5.000000
; ModuleID = 'tmpmodule.26'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 0.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)
0.000000
>Token (TOKEN_FOR)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, =)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ,)
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, <=)
unread Token (TOKEN_OP, <=)
Token (TOKEN_OP, <=)
Token (TOKEN_NUMBER, 20.000000)
Token (TOKEN_LETTER, ,)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
ForExprAST: VarName = a
  InitExpr:
    NumberExprAST val = 1.000000
  CondExpr:
    BinaryExprAST op = <=
      VariableExprAST name = a
      NumberExprAST val = 20.000000
  StepExpr:
    NumberExprAST val = 1.000000
  BlockExpr:
    BlockExprAST: have 1 exprs
      CallExprAST Callee = printc
        Arg #0:
          NumberExprAST val = 42.000000
; ModuleID = 'tmpmodule.27'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  store double 1.000000e+00, double* @a
  br label %for_cmp

for_cmp:                                          ; preds = %for_loop, %0
  %tmp.43 = load double, double* @a
  %tmp.44 = fcmp ole double %tmp.43, 2.000000e+01
  %1 = uitofp i1 %tmp.44 to double
  %2 = fcmp one double %1, 0.000000e+00
  br i1 %2, label %for_loop, label %for_after_loop

for_loop:                                         ; preds = %for_cmp
  %tmp.45 = call double @printc(double 4.200000e+01)
  %3 = load double, double* @a
  %4 = fadd double %3, 1.000000e+00
  store double %4, double* @a
  br label %for_cmp

for_after_loop:                                   ; preds = %for_cmp
  %5 = load double, double* @a
  ret double %5
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)
********************21.000000
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 10.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
CallExprAST Callee = printc
  Arg #0:
    NumberExprAST val = 10.000000
; ModuleID = 'tmpmodule.28'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.46 = call double @printc(double 1.000000e+01)
  ret double %tmp.46
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

0.000000
>Token (TOKEN_DEF)
Token (TOKEN_BINARY)
Token (TOKEN_LETTER, :)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, LHS)
Token (TOKEN_LETTER, ,)
Token (TOKEN_IDENTIFIER, RHS)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_IDENTIFIER, LHS)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_IDENTIFIER, RHS)
Token (TOKEN_LETTER, ;)
unread Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
FunctionAST
  PrototypeAST binary: (LHS, RHS)
  BlockExprAST: have 2 exprs
    VariableExprAST name = LHS
    VariableExprAST name = RHS
; ModuleID = 'tmpmodule.29'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 0.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

define double @"binary:"(double %LHS, double %RHS) {
"binary:.entry":
  %LHS1 = alloca double
  store double %LHS, double* %LHS1
  %RHS2 = alloca double
  store double %RHS, double* %RHS2
  %tmp.47 = load double, double* %LHS1
  %tmp.48 = load double, double* %RHS2
  ret double %tmp.48
}
0.000000
>Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_OP, :)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 10.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
BinaryExprAST op = :
  CallExprAST Callee = printc
    Arg #0:
      NumberExprAST val = 42.000000
  CallExprAST Callee = printc
    Arg #0:
      NumberExprAST val = 10.000000
; ModuleID = 'tmpmodule.30'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.49 = call double @printc(double 4.200000e+01)
  %tmp.50 = call double @printc(double 1.000000e+01)
  %tmp.51 = call double @"binary:"(double %tmp.49, double %tmp.50)
  ret double %tmp.51
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

declare double @"binary:"(double, double)
*
0.000000
>Token (TOKEN_DEF)
Token (TOKEN_UNARY)
Token (TOKEN_LETTER, !)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, RHS)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_IF)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, RHS)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_ELSE)
Token (TOKEN_NUMBER, 1.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
FunctionAST
  PrototypeAST unary! (RHS)
  BlockExprAST: have 1 exprs
    IfExprAST: have 1 CondThenExprs, have 1 ElseExpr
      CondExpr #1
        VariableExprAST name = RHS
      ThenExpr #1
        NumberExprAST val = 0.000000
      ElseExpr
        NumberExprAST val = 1.000000
; ModuleID = 'tmpmodule.31'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 0.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

declare double @"binary:"(double, double)

define double @"unary!"(double %RHS) {
"unary!.entry":
  %RHS1 = alloca double
  store double %RHS, double* %RHS1
  %tmp.52 = load double, double* %RHS1
  %0 = fcmp one double %tmp.52, 0.000000e+00
  br i1 %0, label %if_then, label %if_else

if_then:                                          ; preds = %"unary!.entry"
  br label %if_endif

if_else:                                          ; preds = %"unary!.entry"
  br label %if_endif

if_endif:                                         ; preds = %if_else, %if_then
  %iftmp = phi double [ 0.000000e+00, %if_then ], [ 1.000000e+00, %if_else ]
  ret double %iftmp
}
0.000000
>Token (TOKEN_OP, !)
Token (TOKEN_NUMBER, 3.000000)
Token (TOKEN_LETTER, ;)
UnaryExprAST op = !
  NumberExprAST val = 3.000000
; ModuleID = 'tmpmodule.32'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.53 = call double @"unary!"(double 3.000000e+00)
  ret double %tmp.53
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

declare double @"binary:"(double, double)

declare double @"unary!"(double)
0.000000
Token (TOKEN_OP, !)
Token (TOKEN_NUMBER, 0.000000)
Token (TOKEN_LETTER, ;)
UnaryExprAST op = !
  NumberExprAST val = 0.000000
; ModuleID = 'tmpmodule.33'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.54 = call double @"unary!"(double 0.000000e+00)
  ret double %tmp.54
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

declare double @"binary:"(double, double)

declare double @"unary!"(double)
1.000000
>Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, =)
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ;)
AssignmentExprAST name = a
  NumberExprAST val = 42.000000
; ModuleID = 'tmpmodule.34'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  store double 4.200000e+01, double* @a
  ret double 4.200000e+01
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

declare double @"binary:"(double, double)

declare double @"unary!"(double)
42.000000
Token (TOKEN_DEF)
Token (TOKEN_IDENTIFIER, a_function)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, {)
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, =)
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ;)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_OP, :)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
Token (TOKEN_NUMBER, 32.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
Token (TOKEN_LETTER, })
FunctionAST
  PrototypeAST a_function (a)
  BlockExprAST: have 2 exprs
    AssignmentExprAST name = a
      NumberExprAST val = 42.000000
    BinaryExprAST op = :
      CallExprAST Callee = printc
        Arg #0:
          VariableExprAST name = a
      CallExprAST Callee = printc
        Arg #0:
          BinaryExprAST op = -
            VariableExprAST name = a
            NumberExprAST val = 32.000000
; ModuleID = 'tmpmodule.35'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  ret double 0.000000e+00
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

declare double @"binary:"(double, double)

declare double @"unary!"(double)

define double @a_function(double %a) {
a_function.entry:
  store double %a, double* @a
  store double 4.200000e+01, double* @a
  %tmp.55 = load double, double* @a
  %tmp.56 = call double @printc(double %tmp.55)
  %tmp.57 = load double, double* @a
  %tmp.58 = fsub double %tmp.57, 3.200000e+01
  %tmp.59 = call double @printc(double %tmp.58)
  %tmp.60 = call double @"binary:"(double %tmp.56, double %tmp.59)
  ret double %tmp.60
}
0.000000
>Token (TOKEN_IDENTIFIER, a_function)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_NUMBER, 42.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
CallExprAST Callee = a_function
  Arg #0:
    NumberExprAST val = 42.000000
; ModuleID = 'tmpmodule.36'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.61 = call double @a_function(double 4.200000e+01)
  ret double %tmp.61
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

declare double @"binary:"(double, double)

declare double @"unary!"(double)

declare double @a_function(double)
*
0.000000
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
unread Token (TOKEN_LETTER, ()
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_OP, :)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_LETTER, ))
unread Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ))
Token (TOKEN_OP, :)
Token (TOKEN_IDENTIFIER, printc)
Token (TOKEN_LETTER, ()
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, -)
unread Token (TOKEN_OP, -)
Token (TOKEN_OP, -)
Token (TOKEN_NUMBER, 32.000000)
Token (TOKEN_LETTER, ))
Token (TOKEN_LETTER, ;)
BinaryExprAST op = :
  BinaryExprAST op = :
    CallExprAST Callee = printc
      Arg #0:
        VariableExprAST name = a
    CallExprAST Callee = printc
      Arg #0:
        VariableExprAST name = a
  CallExprAST Callee = printc
    Arg #0:
      BinaryExprAST op = -
        VariableExprAST name = a
        NumberExprAST val = 32.000000
; ModuleID = 'tmpmodule.37'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.62 = load double, double* @a
  %tmp.63 = call double @printc(double %tmp.62)
  %tmp.64 = load double, double* @a
  %tmp.65 = call double @printc(double %tmp.64)
  %tmp.66 = call double @"binary:"(double %tmp.63, double %tmp.65)
  %tmp.67 = load double, double* @a
  %tmp.68 = fsub double %tmp.67, 3.200000e+01
  %tmp.69 = call double @printc(double %tmp.68)
  %tmp.70 = call double @"binary:"(double %tmp.66, double %tmp.69)
  ret double %tmp.70
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

declare double @"binary:"(double, double)

declare double @"unary!"(double)

declare double @a_function(double)
**
0.000000
Token (TOKEN_IDENTIFIER, a)
Token (TOKEN_OP, *)
unread Token (TOKEN_OP, *)
Token (TOKEN_OP, *)
Token (TOKEN_NUMBER, 5.000000)
Token (TOKEN_LETTER, ;)
BinaryExprAST op = *
  VariableExprAST name = a
  NumberExprAST val = 5.000000
; ModuleID = 'tmpmodule.38'

@a = external global double
@b = external global double
@c = external global double

define internal double @__toy_main() {
  %tmp.71 = load double, double* @a
  %tmp.72 = fmul double %tmp.71, 5.000000e+00
  ret double %tmp.72
}

declare double @extern_a(double, double)

declare double @def_a(double, double)

declare double @cse_test(double)

declare double @ta(double, double)

declare double @printc(double)

declare double @"binary:"(double, double)

declare double @"unary!"(double)

declare double @a_function(double)
210.000000
Token (TOKEN_EOF)
